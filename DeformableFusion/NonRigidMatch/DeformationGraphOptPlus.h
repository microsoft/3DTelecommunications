//===============================================
//			DeformGraphOptPlus.h
//			Mingsong Dou (doums@cs.unc.edu)
//===============================================
#ifndef __DEFORMATIONGRAPHOPTIMIZATION_H__
#define __DEFORMATIONGRAPHOPTIMIZATION_H__
#include "DeformationGraphOptBasic.h"
#include "VilToOpenCv.h"

namespace NonrigidMatching{

class DeformGraphOptimizationDataPlus : public DeformGraphOptimizationData
{
public:
	DeformGraphOptimizationDataPlus()
		:vt_sdf_downsample_rate(1),
		 vt_intrinsic_downsample_rate(1),
		 bUseJacHack(false)
	{};
public:
	CSurface<float> surface;
	vector< NeighborGraphNodesOfPoint > ngns_dense;
	SignedDistanceFunc *sdf_target;
	vector< vector<int> > graph_node_territory;

public:
	bool bUseJacHack;
	double w_sdf; //weight for signed distance function
	double w_intersect; //weight for anti intersection
	double w_intrinsic; //weight for isometric mapping term
	int vt_sdf_downsample_rate;
	int vt_intrinsic_downsample_rate;

public:
	int constr_num_dense_points;
	int dense_points_ngn_num_total;
};

class DeformGraphOptMultiDataPlus : public DeformGraphOptMultiData
{
public:
	DeformGraphOptMultiDataPlus()
		:vt_sdf_downsample_rate(1),
		 vt_intrinsic_downsample_rate(1),
		 bUseJacHack(false)
	{};
public:
	vector< CSurface<float>* > surfaces;
	vector< CSurface<float>* > rigid_surfaces;
	vector<NeighborGraphNodesOfPointList*> ngns_dense;
	SignedDistanceFunc *sdf_target;

public:
	bool bUseJacHack;
	double w_sdf; //weight for signed distance function
	double w_intersect; //weight for anti intersection
	double w_intrinsic; //weight for isometric mapping term
	int vt_sdf_downsample_rate;
	int vt_intrinsic_downsample_rate;

};

void deform_graph_optimization_plus(DeformGraphOptimizationDataPlus &data);
void deform_graph_multiObj_opt_plus(DeformGraphOptMultiDataPlus &multi_data);

#ifdef USE_SPARSELM
bool deform_graph_optimization_plus_sparselm(DeformGraphOptimizationDataPlus& data);
#endif

#ifdef USE_CERES_SOLVER
class DeformGraphOptMultiDataPlusStatic : public DeformGraphOptMultiDataStatic
{
public:
	static SignedDistanceFunc *sdf_target;

	static vector<CSurface<float>*> surfaces;
	static vector<NeighborGraphNodesOfPointList*> ngns_dense;
	static vector< GraphNodesTerritory* > graph_node_territory; //need to be computed if not assigned

	static vector<CSurface<float>*> rigid_surfaces;
	static vector< DeformGraph* > rigid_graphs; //assit intersection dection

	static vector< GraphNodesTerritory*> rigid_graph_node_territory; //will or need to be computed automatically before optimization or assigned

public:
	static double w_sdf;
	static double w_intersect;
	static double w_intrinsic;

public://generated by IterCallBackTransSurface
	static vector< CSurface<float> > surfaces_t; 
	static vector< CSurface<float> > rigid_surfaces_t;
	static vector< CSurface<float>*> surfaces_t_all;

public://will or need to be computed automatically before optimization
	static vector< DeformGraph* > graphs_all;	
	static vector< vector< vector<int> >* > graph_node_territory_all;

public:
	static vector<double*> sdf_vals_last_retrieved_rigid_surfs;
	static vector<double*> sdf_vals_last_retrieved_dynamic_surfs;
};

void deform_graph_optimization_plus_ceres(DeformGraphOptMultiDataPlus &data);

//transform the surface
class IterCallBackTransSurface : public ceres::IterationCallback, public DeformGraphOptMultiDataPlusStatic
{
public:
	virtual CallbackReturnType operator()(const IterationSummary& summary)
	{
		printf("-");
		surfaces_t_all.resize(rigid_surfaces.size()+surfaces.size());
		//transform rigid surface
		rigid_surfaces_t.resize(rigid_surfaces.size());
		for(int i=0; i<rigid_transfs.size(); i++)
		{
			rigid_surfaces_t[i] = *(rigid_surfaces[i]);
			transform_Surface_with_RigidModel(rigid_surfaces_t[i], *(rigid_transfs[i]));
			surfaces_t_all.push_back(&rigid_surfaces_t[i]);
		}
		//transform dynamic surface
		surfaces_t.resize(surfaces.size());
		for(int i=0; i<graphs.size(); i++)
		{
			surfaces_t[i] = *(surfaces[i]);
			transform_Surface_with_DeformGraph(surfaces_t[i], *(graphs[i]), *(ngns_dense[i]), false); 
			surfaces_t_all.push_back(&surfaces_t[i]);
		}
		printf(">");

		return SOLVER_CONTINUE;
	}
};

namespace AntiSelfInterSectionTerm{
	class F : public CostFunction, public DeformGraphOptMultiDataPlusStatic
	{
	public:
		F(int graphIdx_, int vtIdx_ )
		{
			assert( graphIdx_ < graphs.size() );
			this->graphIdx = graphIdx_;

			assert(vtIdx_ < surfaces[graphIdx]->vtNum );
			this->vtIdx = vtIdx_;
			
			this->ngn = &((*(ngns_dense[graphIdx]))[vtIdx]);
			float *p = surfaces[graphIdx]->vt_data_block(vtIdx_);
			this->v = vnl_vector_fixed<double, 3>(p[0], p[1], p[2]);
			float *n_ = surfaces[graphIdx]->vt_normal(vtIdx_);
			this->n = vnl_vector_fixed<double, 3>(n_[0], n_[1], n_[2]);

			this->set_num_residuals(1);
			int ngn_num = this->ngn->neighborIndices.size();
			for(int i=0; i<ngn_num; i++)
			{
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
			}
		}
		~F() {};

	public:
		virtual bool Evaluate(double const* const* parameters,
					double* residuals,
					double** jacobians) const
		{
		// Steps: 1. find the nearby graph nodes that has big possibility of collision
		//	      2. find the nearest vertex among the vertices governed by above nodes
		//		  3. check its position relative to the nearest vertex

			double thres_collision_dist = 10.0;

			vector< vector<int> > const& graph_node_territory_s = *(graph_node_territory[graphIdx]);
			CSurface<float> const& surface_t = surfaces_t[graphIdx];
			DeformGraph *graph = graphs[graphIdx];
			CSurface<float> const* surface = surfaces[graphIdx];

			const float *q = surface_t.vt_data_block(this->vtIdx);
			vnl_vector_fixed<double, 3> vq(q[0], q[1], q[2]);
			const float *nq_ = surface_t.vt_normal(this->vtIdx);
			vnl_vector_fixed<double, 3> nq(nq_[0], nq_[1], nq_[2]);
			
			//find graph nodes that the current vertex is going to collide
			vector<int> nodes_list_candidate;
			for(int i=0; i<graph->nodes.size(); i++)
			{
				//skip its neighbors
				if( search_val_list(this->ngn->neighborIndices, i) >= 0 )
					continue;

				DeformGraphNode const& node = graph->nodes[i];
				double dist_cur = dist_3d( vq, node.g+node.t );//distance on the surface_t					
				double dist_ref = dist_3d( v, node.g ); //distance on surface

				if( dist_cur < thres_collision_dist &&
					dist_cur < 0.3*dist_ref )
					nodes_list_candidate.push_back(i);
			}
						
			int vtIdx_min = -1;//nearest vertex that is going to collide
			double dist_min = 1.0e+10;
			for(int c=0; c<nodes_list_candidate.size(); c++)
			{
				int ndIdx = nodes_list_candidate[c];
				vector<int> const& vt_list = graph_node_territory_s[ndIdx];
				for(int i=0; i<vt_list.size(); i++)
				{
					int vtIdx_nr = vt_list[i];
					float const*vq_nr_ = surface_t.vt_data_block(vtIdx_nr);
					vnl_vector_fixed<double, 3> vq_nr(vq_nr_[0], vq_nr_[1], vq_nr_[2]);
					float const*v_nr_ = surface->vt_data_block(vtIdx_nr);
					vnl_vector_fixed<double, 3> v_nr(v_nr_[0], v_nr_[1], v_nr_[2]);

					double dist_cur = dist_3d(vq, vq_nr);
					double dist_ref = dist_3d(v, v_nr);
					if( dist_cur < dist_min &&
						dist_cur < 0.1*dist_ref)
					{
						dist_min = dist_cur;
						vtIdx_min = vtIdx_nr;
					}
				}
			}

			bool bCollided = false;
			if( vtIdx_min != -1 )
			{
				float const*vq_nr_ = surface_t.vt_data_block(vtIdx_min);
				vnl_vector_fixed<double, 3> vq_nr(vq_nr_[0], vq_nr_[1], vq_nr_[2]);
				float const*nq_nr_ = surface_t.vt_normal(vtIdx_min);
				vnl_vector_fixed<double, 3> nq_nr(nq_nr_[0], nq_nr_[1], nq_nr_[2]);

				if( angle_btw_two_vec(nq_nr, vq - vq_nr) * 180/M_PI < 80 &&
					angle_btw_two_vec(nq, vq_nr-vq) * 180/M_PI < 80 )
				{
					//elinimate the situation when two surfaces are from two sides of the same part
					float const*v_nr_ = surface->vt_data_block(vtIdx_min);
					vnl_vector_fixed<double, 3> v_nr(v_nr_[0], v_nr_[1], v_nr_[2]);
					float const*n_nr_ = surface->vt_normal(vtIdx_min);
					vnl_vector_fixed<double, 3> n_nr(n_nr_[0], n_nr_[1], n_nr_[2]);

					if( dot_product(v-v_nr, n_nr) > 0 &&
						dist_3d(v, v_nr)<20.0 )
						bCollided = false;
					else
						bCollided = true;
				}
			}

			int ngn_num = this->ngn->neighborIndices.size();
			if( !bCollided )
			{
				residuals[0] = 0.0;
				if( jacobians != NULL ){
					for(int i=0; i<ngn_num; i++){
						if( jacobians[6*i] != NULL )
							memset(&(jacobians[6*i][0]), 0, sizeof(double)*3);	
						if( jacobians[6*i+1] != NULL )
							memset(&(jacobians[6*i+1][0]), 0, sizeof(double)*3);
						if( jacobians[6*i+2] != NULL )
							memset(&(jacobians[6*i+2][0]), 0, sizeof(double)*3);				
						if( jacobians[6*i+3] != NULL )
							jacobians[6*i+3][0] = 0;
						if( jacobians[6*i+4] != NULL )
							jacobians[6*i+4][0] = 0;
						if( jacobians[6*i+5] != NULL )
							jacobians[6*i+5][0] = 0;
					}
				}
			}
			else
			{
				float const*v_nr_ = surface_t.vt_data_block(vtIdx_min);
				vnl_vector_fixed<double, 3> v_nr(v_nr_[0], v_nr_[1], v_nr_[2]);
				float const*n_nr_ = surface_t.vt_normal(vtIdx_min);
				vnl_vector_fixed<double, 3> n_nr(n_nr_[0], n_nr_[1], n_nr_[2]);

				residuals[0] = dot_product(vq-v_nr, n_nr);
				if( jacobians != NULL )
				{
					for(int i=0; i<ngn_num; i++)
					{
						int ndIdx = this->ngn->neighborIndices[i];
						double w = this->ngn->weights[i];
						vnl_vector_fixed<double, 3> const& g_k = graph->nodes[ndIdx].g;
						vnl_vector_fixed<double, 3> tmp( v[0]-g_k[0], 
														 v[1]-g_k[1], 
														 v[2]-g_k[2]);

						if( jacobians[6*i] != NULL )
						{
							jacobians[6*i][0] = tmp[0]*n_nr[0]*w;
							jacobians[6*i][1] = tmp[1]*n_nr[0]*w;
							jacobians[6*i][2] = tmp[2]*n_nr[0]*w;
						}
						if( jacobians[6*i+1] != NULL )
						{
							jacobians[6*i+1][0] = tmp[0]*n_nr[1]*w;
							jacobians[6*i+1][1] = tmp[1]*n_nr[1]*w;
							jacobians[6*i+1][2] = tmp[2]*n_nr[1]*w;
						}
						if( jacobians[6*i+2] != NULL )
						{
							jacobians[6*i+2][0] = tmp[0]*n_nr[2]*w;
							jacobians[6*i+2][1] = tmp[1]*n_nr[2]*w;
							jacobians[6*i+2][2] = tmp[2]*n_nr[2]*w;
						}
				
						if( jacobians[6*i+3] != NULL )
							jacobians[6*i+3][0] = n_nr[0]*w;
						if( jacobians[6*i+4] != NULL )
							jacobians[6*i+4][0] = n_nr[1]*w;
						if( jacobians[6*i+5] != NULL )
							jacobians[6*i+5][0] = n_nr[2]*w;
					}
				}
			}

			return true;
		}

	private:
		int graphIdx;
		int vtIdx;
		vnl_vector_fixed<double, 3> v;	
		vnl_vector_fixed<double, 3> n;
		NeighborGraphNodesOfPoint *ngn;
	};
};

namespace AntiInterSectionDynamicObjTerm{

	class F: public CostFunction, public DeformGraphOptMultiDataPlusStatic
	{
	public:
		F(int graphIdx_, int vtIdx_ )
		{
			assert( graphIdx_ < graphs.size() );
			this->graphIdx = graphIdx_;

			assert(vtIdx_ < surfaces[graphIdx]->vtNum );
			this->vtIdx = vtIdx_;
			
			this->ngn = &((*(ngns_dense[graphIdx]))[vtIdx]);
			float *p = surfaces[graphIdx]->vt_data_block(vtIdx_);
			this->v = vnl_vector_fixed<double, 3>(p[0], p[1], p[2]);
			float *n_ = surfaces[graphIdx]->vt_normal(vtIdx_);
			this->n = vnl_vector_fixed<double, 3>(n_[0], n_[1], n_[2]);

			this->set_num_residuals(1);
			int ngn_num = this->ngn->neighborIndices.size();
			for(int i=0; i<ngn_num; i++)
			{
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
			}
		}
		~F() {};

	public:
		virtual bool Evaluate(double const* const* parameters,
					double* residuals,
					double** jacobians) const
		{
			double thres_collision_dist = 10.0;

			DeformGraph *graph = graphs[graphIdx];
			CSurface<float> const* surface = surfaces[graphIdx];
			CSurface<float> const& surface_t = surfaces_t[graphIdx];

			const float *q = surface_t.vt_data_block(this->vtIdx);
			vnl_vector_fixed<double, 3> vq(q[0], q[1], q[2]);
			const float *nq_ = surface_t.vt_normal(this->vtIdx);
			vnl_vector_fixed<double, 3> nq(nq_[0], nq_[1], nq_[2]);
			
			int rigid_obj_num = rigid_graphs.size();
			int obj_num = rigid_graphs.size() + graphs.size();

			//find graph nodes that the current vertex is going to collide
			vector<pair<int, int> > nodes_list_candidate;
			for(int objId=0; objId<obj_num; objId++)
			{
				//ignore itself
				if( objId == rigid_obj_num + this->graphIdx )
					continue;

				DeformGraph *obj_graph = graphs_all[objId];
				for(int i=0; i<obj_graph->nodes.size(); i++)
				{
					DeformGraphNode const& node = obj_graph->nodes[i];
					double dist_cur;
					if( objId >= rigid_obj_num )
						dist_cur = dist_3d( vq, node.g+node.t);//distance on the surface_t					
					else
					{
						vnl_matrix_fixed<double, 3, 3> R;
						rodrigues_to_matrix(rigid_transfs[objId]->rod, R);
						dist_cur = dist_3d( vq, R*node.g + rigid_transfs[objId]->t); 
					}
					if( dist_cur < thres_collision_dist )
						nodes_list_candidate.push_back(make_pair(objId, i));					
				}
			}
						
			//find nearest vertex that is going to collide
			pair<int, int> vt_nn(-1, -1);
			double dist_min = 1.0e+10;
			for(int c=0; c<nodes_list_candidate.size(); c++)
			{
				int objIdx = nodes_list_candidate[c].first;
				int ndIdx = nodes_list_candidate[c].second;
				CSurface<float> const*surface_t_cur = surfaces_t_all[objIdx];
				vector<int> const& vt_list = (*(graph_node_territory_all[objIdx]))[ndIdx];
				for(int i=0; i<vt_list.size(); i++)
				{
					int vtIdx_nr = vt_list[i];
					float const*vq_nr_ = surface_t_cur->vt_data_block(vtIdx_nr);
					vnl_vector_fixed<double, 3> vq_nr(vq_nr_[0], vq_nr_[1], vq_nr_[2]);

					double dist_cur = dist_3d(vq, vq_nr);
					if( dist_cur < dist_min)
					{
						dist_min = dist_cur;
						vt_nn = make_pair(objIdx, vtIdx_nr);
					}
				}
			}

			bool bCollided = false;
			if( vt_nn.first != -1 )
			{
				int objIdx_min = vt_nn.first;
				int vtIdx_min = vt_nn.second;
				CSurface<float> const*surface_t_min = surfaces_t_all[objIdx_min];

				float const*vq_nr_ = surface_t_min->vt_data_block(vtIdx_min);
				vnl_vector_fixed<double, 3> vq_nr(vq_nr_[0], vq_nr_[1], vq_nr_[2]);
				float const*nq_nr_ = surface_t_min->vt_normal(vtIdx_min);
				vnl_vector_fixed<double, 3> nq_nr(nq_nr_[0], nq_nr_[1], nq_nr_[2]);

				if( angle_btw_two_vec(nq_nr, vq - vq_nr) * 180/M_PI < 80 &&
					angle_btw_two_vec(nq, vq_nr - vq) * 180/M_PI < 80 )
				{
					bCollided = true;
				}
			}

			int ngn_num = this->ngn->neighborIndices.size();
			if( !bCollided )
			{
				residuals[0] = 0.0;
				if( jacobians != NULL ){
					for(int i=0; i<ngn_num; i++){
						if( jacobians[6*i] != NULL )
							memset(&(jacobians[6*i][0]), 0, sizeof(double)*3);	
						if( jacobians[6*i+1] != NULL )
							memset(&(jacobians[6*i+1][0]), 0, sizeof(double)*3);
						if( jacobians[6*i+2] != NULL )
							memset(&(jacobians[6*i+2][0]), 0, sizeof(double)*3);				
						if( jacobians[6*i+3] != NULL )
							jacobians[6*i+3][0] = 0;
						if( jacobians[6*i+4] != NULL )
							jacobians[6*i+4][0] = 0;
						if( jacobians[6*i+5] != NULL )
							jacobians[6*i+5][0] = 0;
					}
				}
			}
			else
			{
				int objIdx_min = vt_nn.first;
				int vtIdx_min = vt_nn.second;
				CSurface<float> const*surface_t_min = surfaces_t_all[objIdx_min];
				float const*vq_nr_ = surface_t_min->vt_data_block(vtIdx_min);
				vnl_vector_fixed<double, 3> vq_nr(vq_nr_[0], vq_nr_[1], vq_nr_[2]);
				float const*nq_nr_ = surface_t_min->vt_normal(vtIdx_min);
				vnl_vector_fixed<double, 3> nq_nr(nq_nr_[0], nq_nr_[1], nq_nr_[2]);

				residuals[0] = dot_product(vq-vq_nr, nq_nr);
				if( jacobians != NULL )
				{
					for(int i=0; i<ngn_num; i++)
					{
						int ndIdx = this->ngn->neighborIndices[i];
						double w = this->ngn->weights[i];
						vnl_vector_fixed<double, 3> const& g_k = graph->nodes[ndIdx].g;
						vnl_vector_fixed<double, 3> tmp( v[0]-g_k[0], 
														 v[1]-g_k[1], 
														 v[2]-g_k[2]);

						if( jacobians[6*i] != NULL )
						{
							jacobians[6*i][0] = tmp[0]*nq_nr[0]*w;
							jacobians[6*i][1] = tmp[1]*nq_nr[0]*w;
							jacobians[6*i][2] = tmp[2]*nq_nr[0]*w;
						}
						if( jacobians[6*i+1] != NULL )
						{
							jacobians[6*i+1][0] = tmp[0]*nq_nr[1]*w;
							jacobians[6*i+1][1] = tmp[1]*nq_nr[1]*w;
							jacobians[6*i+1][2] = tmp[2]*nq_nr[1]*w;
						}
						if( jacobians[6*i+2] != NULL )
						{
							jacobians[6*i+2][0] = tmp[0]*nq_nr[2]*w;
							jacobians[6*i+2][1] = tmp[1]*nq_nr[2]*w;
							jacobians[6*i+2][2] = tmp[2]*nq_nr[2]*w;
						}
				
						if( jacobians[6*i+3] != NULL )
							jacobians[6*i+3][0] = nq_nr[0]*w;
						if( jacobians[6*i+4] != NULL )
							jacobians[6*i+4][0] = nq_nr[1]*w;
						if( jacobians[6*i+5] != NULL )
							jacobians[6*i+5][0] = nq_nr[2]*w;
					}
				}
			}

			return true;
		}

	private:
		int graphIdx;
		int vtIdx;
		vnl_vector_fixed<double, 3> v;	
		vnl_vector_fixed<double, 3> n;
		NeighborGraphNodesOfPoint *ngn;
	};

};

namespace IsometricTerm{
	//parameters: [r0, r1, r2, t0, t1, t2; r0, r1, r2, t0, t1, t2; ...]
	class F : public CostFunction, public DeformGraphOptMultiDataPlusStatic
	{
	public:
		//ngn_indices_: the neighboring graph nodes of all three vertices
		F(int graphIdx_, int vtIdx1_, int vtIdx2_, int vtIdx3_, vector<int> const& ngn_indices_ )
		{
			assert( graphIdx_ < graphs.size() );
			this->graphIdx = graphIdx_;

			assert( vtIdx1_ < DeformGraphOptMultiDataPlusStatic::surfaces[graphIdx]->vtNum);
			assert( vtIdx2_ < DeformGraphOptMultiDataPlusStatic::surfaces[graphIdx]->vtNum);
			assert( vtIdx3_ < DeformGraphOptMultiDataPlusStatic::surfaces[graphIdx]->vtNum);
			this->vtIdx1 = vtIdx1_;
			this->vtIdx2 = vtIdx2_;
			this->vtIdx3 = vtIdx3_;
			this->ngn_indices = ngn_indices_;

			float *p1 = surfaces[graphIdx]->vt_data_block(vtIdx1);
			float *p2 = surfaces[graphIdx]->vt_data_block(vtIdx2);
			float *p3 = surfaces[graphIdx]->vt_data_block(vtIdx3);
			this->vt1 = vnl_vector_fixed<double, 3>(p1[0], p1[1], p1[2]);
			this->vt2 = vnl_vector_fixed<double, 3>(p2[0], p2[1], p2[2]);
			this->vt3 = vnl_vector_fixed<double, 3>(p3[0], p3[1], p3[2]);

			this->inner_prod_1 = dot_product(vt2-vt1, vt3-vt1);
			this->inner_prod_2 = dot_product(vt3-vt2, vt1-vt2);
			this->inner_prod_3 = dot_product(vt1-vt3, vt2-vt3);

			vector<int> const& ngn_list1 = (*(ngns_dense[graphIdx]))[vtIdx1].neighborIndices;
			vector<double> const& ngn_weights1 = (*(ngns_dense[graphIdx]))[vtIdx1].weights;
			vector<int> const& ngn_list2 = (*(ngns_dense[graphIdx]))[vtIdx2].neighborIndices;
			vector<double> const& ngn_weights2 = (*(ngns_dense[graphIdx]))[vtIdx2].weights;
			vector<int> const& ngn_list3 = (*(ngns_dense[graphIdx]))[vtIdx3].neighborIndices;
			vector<double> const& ngn_weights3 = (*(ngns_dense[graphIdx]))[vtIdx3].weights;
			
			this->ngnWeights_vt1.resize(ngn_indices.size());
			this->ngnWeights_vt2.resize(ngn_indices.size());
			this->ngnWeights_vt3.resize(ngn_indices.size());
			for(int i=0; i<ngn_indices.size(); i++)
			{
				int ngnIdx = ngn_indices[i];
				assert(ngnIdx >=0 && ngnIdx < graphs[graphIdx]->nodes.size() );

				int index1 = search_val_list(ngn_list1, ngnIdx);
				if( index1==-1)
					ngnWeights_vt1[i] = 0.0;
				else
					ngnWeights_vt1[i] = ngn_weights1[index1];

				int index2 = search_val_list(ngn_list2, ngnIdx);
				if( index2==-1)
					ngnWeights_vt2[i] = 0.0;
				else
					ngnWeights_vt2[i] = ngn_weights2[index2];

				int index3 = search_val_list(ngn_list3, ngnIdx);
				if( index3==-1)
					ngnWeights_vt3[i] = 0.0;
				else
					ngnWeights_vt3[i] = ngn_weights3[index3];
			}

			this->set_num_residuals(3);
			for(int i=0; i<ngn_indices.size(); i++)
			{
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
			}
		}
		~F(){};

	public:
		virtual bool Evaluate(double const* const* parameters,
					double* residuals,
					double** jacobians) const
		{
			CSurface<float> const& surface_t = surfaces_t[graphIdx];
			DeformGraph *graph = graphs[graphIdx];

			const float* q1 = surface_t.vt_data_block(this->vtIdx1);
			const float* q2 = surface_t.vt_data_block(this->vtIdx2);
			const float* q3 = surface_t.vt_data_block(this->vtIdx3);
			vnl_vector_fixed<double, 3> vq1(q1[0], q1[1], q1[2]);
			vnl_vector_fixed<double, 3> vq2(q2[0], q2[1], q2[2]);
			vnl_vector_fixed<double, 3> vq3(q3[0], q3[1], q3[2]);

			//remove the global rigid movement
			vnl_vector_fixed<double, 3> const& T_global = graph->global_rigid.t;
			vnl_matrix_fixed<double, 3, 3> R_global = graph->global_rigid.rotation();
			vq1 = R_global.transpose() *(vq1 - T_global);
			vq2 = R_global.transpose() *(vq2 - T_global);
			vq3 = R_global.transpose() *(vq3 - T_global);

			residuals[0] = dot_product(vq2-vq1, vq3-vq1) - inner_prod_1;
			residuals[1] = dot_product(vq3-vq2, vq1-vq2) - inner_prod_2;
			residuals[2] = dot_product(vq1-vq3, vq2-vq3) - inner_prod_3;

			if( jacobians != NULL )
			{
				vnl_vector_fixed<double, 3> f1_vq1 = 2.0*vq1-vq2-vq3;
				vnl_vector_fixed<double, 3> f1_vq2 = vq3-vq1;
				vnl_vector_fixed<double, 3> f1_vq3 = vq2-vq1;

				vnl_vector_fixed<double, 3> f2_vq1 = vq3-vq2;
				vnl_vector_fixed<double, 3> f2_vq2 = 2.0*vq2-vq3-vq1;
				vnl_vector_fixed<double, 3> f2_vq3 = vq1-vq2;

				vnl_vector_fixed<double, 3> f3_vq1 = vq2-vq3;
				vnl_vector_fixed<double, 3> f3_vq2 = vq1-vq3;
				vnl_vector_fixed<double, 3> f3_vq3 = 2.0*vq3-vq2-vq1;

				for(int i=0; i<ngn_indices.size(); i++)
				{
					int ndIdx = ngn_indices[i];
					vnl_vector_fixed<double, 3> const& g_k = graph->nodes[ndIdx].g;
					double w1 = this->ngnWeights_vt1[i];
					double w2 = this->ngnWeights_vt2[i];
					double w3 = this->ngnWeights_vt3[i];
					vnl_vector_fixed<double, 3> tmp1 = this->vt1-g_k;
					vnl_vector_fixed<double, 3> tmp2 = this->vt2-g_k;
					vnl_vector_fixed<double, 3> tmp3 = this->vt3-g_k;

					if( jacobians[6*i] != NULL)
					{
						jacobians[6*i][0] = w1*f1_vq1[0]*tmp1[0] + w2*f1_vq2[0]*tmp2[0] + w3*f1_vq3[0]*tmp3[0];
						jacobians[6*i][1] = w1*f1_vq1[0]*tmp1[1] + w2*f1_vq2[0]*tmp2[1] + w3*f1_vq3[0]*tmp3[1];
						jacobians[6*i][2] = w1*f1_vq1[0]*tmp1[2] + w2*f1_vq2[0]*tmp2[2] + w3*f1_vq3[0]*tmp3[2];

						jacobians[6*i][3] = w1*f2_vq1[0]*tmp1[0] + w2*f2_vq2[0]*tmp2[0] + w3*f2_vq3[0]*tmp3[0];
						jacobians[6*i][4] = w1*f2_vq1[0]*tmp1[1] + w2*f2_vq2[0]*tmp2[1] + w3*f2_vq3[0]*tmp3[1];
						jacobians[6*i][5] = w1*f2_vq1[0]*tmp1[2] + w2*f2_vq2[0]*tmp2[2] + w3*f2_vq3[0]*tmp3[2];

						jacobians[6*i][6] = w1*f3_vq1[0]*tmp1[0] + w2*f3_vq2[0]*tmp2[0] + w3*f3_vq3[0]*tmp3[0];
						jacobians[6*i][7] = w1*f3_vq1[0]*tmp1[1] + w2*f3_vq2[0]*tmp2[1] + w3*f3_vq3[0]*tmp3[1];
						jacobians[6*i][8] = w1*f3_vq1[0]*tmp1[2] + w2*f3_vq2[0]*tmp2[2] + w3*f3_vq3[0]*tmp3[2];
					}

					if( jacobians[6*i+1] != NULL)
					{
						jacobians[6*i+1][0] = w1*f1_vq1[1]*tmp1[0] + w2*f1_vq2[1]*tmp2[0] + w3*f1_vq3[1]*tmp3[0];
						jacobians[6*i+1][1] = w1*f1_vq1[1]*tmp1[1] + w2*f1_vq2[1]*tmp2[1] + w3*f1_vq3[1]*tmp3[1];
						jacobians[6*i+1][2] = w1*f1_vq1[1]*tmp1[2] + w2*f1_vq2[1]*tmp2[2] + w3*f1_vq3[1]*tmp3[2];											

						jacobians[6*i+1][3] = w1*f2_vq1[1]*tmp1[0] + w2*f2_vq2[1]*tmp2[0] + w3*f2_vq3[1]*tmp3[0];
						jacobians[6*i+1][4] = w1*f2_vq1[1]*tmp1[1] + w2*f2_vq2[1]*tmp2[1] + w3*f2_vq3[1]*tmp3[1];
						jacobians[6*i+1][5] = w1*f2_vq1[1]*tmp1[2] + w2*f2_vq2[1]*tmp2[2] + w3*f2_vq3[1]*tmp3[2];

						jacobians[6*i+1][6] = w1*f3_vq1[1]*tmp1[0] + w2*f3_vq2[1]*tmp2[0] + w3*f3_vq3[1]*tmp3[0];
						jacobians[6*i+1][7] = w1*f3_vq1[1]*tmp1[1] + w2*f3_vq2[1]*tmp2[1] + w3*f3_vq3[1]*tmp3[1];
						jacobians[6*i+1][8] = w1*f3_vq1[1]*tmp1[2] + w2*f3_vq2[1]*tmp2[2] + w3*f3_vq3[1]*tmp3[2];
					}

					if( jacobians[6*i+2] != NULL)
					{
						jacobians[6*i+2][0] = w1*f1_vq1[2]*tmp1[0] + w2*f1_vq2[2]*tmp2[0] + w3*f1_vq3[2]*tmp3[0];
						jacobians[6*i+2][1] = w1*f1_vq1[2]*tmp1[1] + w2*f1_vq2[2]*tmp2[1] + w3*f1_vq3[2]*tmp3[1];
						jacobians[6*i+2][2] = w1*f1_vq1[2]*tmp1[2] + w2*f1_vq2[2]*tmp2[2] + w3*f1_vq3[2]*tmp3[2];

						jacobians[6*i+2][3] = w1*f2_vq1[2]*tmp1[0] + w2*f2_vq2[2]*tmp2[0] + w3*f2_vq3[2]*tmp3[0];
						jacobians[6*i+2][4] = w1*f2_vq1[2]*tmp1[1] + w2*f2_vq2[2]*tmp2[1] + w3*f2_vq3[2]*tmp3[1];
						jacobians[6*i+2][5] = w1*f2_vq1[2]*tmp1[2] + w2*f2_vq2[2]*tmp2[2] + w3*f2_vq3[2]*tmp3[2];

						jacobians[6*i+2][6] = w1*f3_vq1[2]*tmp1[0] + w2*f3_vq2[2]*tmp2[0] + w3*f3_vq3[2]*tmp3[0];
						jacobians[6*i+2][7] = w1*f3_vq1[2]*tmp1[1] + w2*f3_vq2[2]*tmp2[1] + w3*f3_vq3[2]*tmp3[1];
						jacobians[6*i+2][8] = w1*f3_vq1[2]*tmp1[2] + w2*f3_vq2[2]*tmp2[2] + w3*f3_vq3[2]*tmp3[2];
					}

					if( jacobians[6*i+3] != NULL )
					{
						jacobians[6*i+3][0] = w1*f1_vq1[0] + w2*f1_vq2[0] + w3*f1_vq3[0];

						jacobians[6*i+3][1] = w1*f2_vq1[0] + w2*f2_vq2[0] + w3*f2_vq3[0];

						jacobians[6*i+3][2] = w1*f3_vq1[0] + w2*f3_vq2[0] + w3*f3_vq3[0];
					}

					if( jacobians[6*i+4] != NULL )
					{
						jacobians[6*i+4][0] = w1*f1_vq1[1] + w2*f1_vq2[1] + w3*f1_vq3[1];

						jacobians[6*i+4][1] = w1*f2_vq1[1] + w2*f2_vq2[1] + w3*f2_vq3[1];

						jacobians[6*i+4][2] = w1*f3_vq1[1] + w2*f3_vq2[1] + w3*f3_vq3[1];
					}

					if( jacobians[6*i+5] != NULL )
					{
						jacobians[6*i+5][0] = w1*f1_vq1[2] + w2*f1_vq2[2] + w3*f1_vq3[2];

						jacobians[6*i+5][1] = w1*f2_vq1[2] + w2*f2_vq2[2] + w3*f2_vq3[2];

						jacobians[6*i+5][2] = w1*f3_vq1[2] + w2*f3_vq2[2] + w3*f3_vq3[2];
					}
				}
			}

			return true;
		}

	private:
		int graphIdx;
		int vtIdx1;
		int vtIdx2;
		int vtIdx3;

		vnl_vector_fixed<double, 3> vt1;
		vnl_vector_fixed<double, 3> vt2;
		vnl_vector_fixed<double, 3> vt3;

		vector<int> ngn_indices;
		vector<float> ngnWeights_vt1;
		vector<float> ngnWeights_vt2;
		vector<float> ngnWeights_vt3;

		//inner product of two edges of a triangular on the tangent plane
		double inner_prod_1;// two edges connected by vt1
		double inner_prod_2;// two edges connected by vt2
		double inner_prod_3;// two edges connected by vt3		

	};

	//inefficient, but gradient_check capable
	//parameters: [r0, r1, r2, t0, t1, t2; r0, r1, r2, t0, t1, t2; ...]
	class F_ : public CostFunction, public DeformGraphOptMultiDataPlusStatic
	{
	public:
		//ngn_indices_: the neighboring graph nodes of all three vertices
		F_(int graphIdx_, int vtIdx1_, int vtIdx2_, int vtIdx3_, vector<int> const& ngn_indices_)
		{
			assert(graphIdx_ < graphs.size());
			this->graphIdx = graphIdx_;

			assert(vtIdx1_ < DeformGraphOptMultiDataPlusStatic::surfaces[graphIdx]->vtNum);
			assert(vtIdx2_ < DeformGraphOptMultiDataPlusStatic::surfaces[graphIdx]->vtNum);
			assert(vtIdx3_ < DeformGraphOptMultiDataPlusStatic::surfaces[graphIdx]->vtNum);
			this->vtIdx1 = vtIdx1_;
			this->vtIdx2 = vtIdx2_;
			this->vtIdx3 = vtIdx3_;
			this->ngn_indices = ngn_indices_;

			float *p1 = surfaces[graphIdx]->vt_data_block(vtIdx1);
			float *p2 = surfaces[graphIdx]->vt_data_block(vtIdx2);
			float *p3 = surfaces[graphIdx]->vt_data_block(vtIdx3);
			this->vt1 = vnl_vector_fixed<double, 3>(p1[0], p1[1], p1[2]);
			this->vt2 = vnl_vector_fixed<double, 3>(p2[0], p2[1], p2[2]);
			this->vt3 = vnl_vector_fixed<double, 3>(p3[0], p3[1], p3[2]);

			this->inner_prod_1 = dot_product(vt2 - vt1, vt3 - vt1);
			this->inner_prod_2 = dot_product(vt3 - vt2, vt1 - vt2);
			this->inner_prod_3 = dot_product(vt1 - vt3, vt2 - vt3);

			vector<int> const& ngn_list1 = (*(ngns_dense[graphIdx]))[vtIdx1].neighborIndices;
			vector<double> const& ngn_weights1 = (*(ngns_dense[graphIdx]))[vtIdx1].weights;
			vector<int> const& ngn_list2 = (*(ngns_dense[graphIdx]))[vtIdx2].neighborIndices;
			vector<double> const& ngn_weights2 = (*(ngns_dense[graphIdx]))[vtIdx2].weights;
			vector<int> const& ngn_list3 = (*(ngns_dense[graphIdx]))[vtIdx3].neighborIndices;
			vector<double> const& ngn_weights3 = (*(ngns_dense[graphIdx]))[vtIdx3].weights;

			this->ngnWeights_vt1.resize(ngn_indices.size());
			this->ngnWeights_vt2.resize(ngn_indices.size());
			this->ngnWeights_vt3.resize(ngn_indices.size());
			for (int i = 0; i<ngn_indices.size(); i++)
			{
				int ngnIdx = ngn_indices[i];
				assert(ngnIdx >= 0 && ngnIdx < graphs[graphIdx]->nodes.size());

				int index1 = search_val_list(ngn_list1, ngnIdx);
				if (index1 == -1)
					ngnWeights_vt1[i] = 0.0;
				else
					ngnWeights_vt1[i] = ngn_weights1[index1];

				int index2 = search_val_list(ngn_list2, ngnIdx);
				if (index2 == -1)
					ngnWeights_vt2[i] = 0.0;
				else
					ngnWeights_vt2[i] = ngn_weights2[index2];

				int index3 = search_val_list(ngn_list3, ngnIdx);
				if (index3 == -1)
					ngnWeights_vt3[i] = 0.0;
				else
					ngnWeights_vt3[i] = ngn_weights3[index3];
			}

			this->set_num_residuals(3);
			for (int i = 0; i<ngn_indices.size(); i++)
			{
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
			}
		}
		~F_(){};

	public:
		virtual bool Evaluate(double const* const* parameters,
			double* residuals,
			double** jacobians) const
		{
			CSurface<float> const& surface_t = surfaces_t[graphIdx];
			DeformGraph *graph = graphs[graphIdx];
			int ngn_num = ngn_indices.size();

			vnl_vector_fixed<double, 3> vq1(0.0);
			vnl_vector_fixed<double, 3> vq2(0.0);
			vnl_vector_fixed<double, 3> vq3(0.0);
			for (int i = 0; i < ngn_indices.size(); i++)
			{
				int ndIdx = ngn_indices[i];
				vnl_vector_fixed<double, 3> const& g_k = graph->nodes[ndIdx].g;
				double w1 = this->ngnWeights_vt1[i];
				double w2 = this->ngnWeights_vt2[i];
				double w3 = this->ngnWeights_vt3[i];
				vnl_matrix_fixed<double, 3, 3> A_k(0.0);
				A_k.set_row(0, parameters[6 * i]);
				A_k.set_row(1, parameters[6 * i+1]);
				A_k.set_row(2, parameters[6 * i+2]);
				vnl_vector_fixed<double, 3> t_k(parameters[6 * i + 3][0], parameters[6 * i + 4][0], parameters[6 * i + 5][0]);

				vq1 += (A_k*(vt1 - g_k) + g_k + t_k)*w1;
				vq2 += (A_k*(vt2 - g_k) + g_k + t_k)*w2;
				vq3 += (A_k*(vt3 - g_k) + g_k + t_k)*w3;
			}

			residuals[0] = dot_product(vq2 - vq1, vq3 - vq1) - inner_prod_1;
			residuals[1] = dot_product(vq3 - vq2, vq1 - vq2) - inner_prod_2;
			residuals[2] = dot_product(vq1 - vq3, vq2 - vq3) - inner_prod_3;

			if (jacobians != NULL)
			{
				vnl_vector_fixed<double, 3> f1_vq1 = 2.0*vq1 - vq2 - vq3;
				vnl_vector_fixed<double, 3> f1_vq2 = vq3 - vq1;
				vnl_vector_fixed<double, 3> f1_vq3 = vq2 - vq1;

				vnl_vector_fixed<double, 3> f2_vq1 = vq3 - vq2;
				vnl_vector_fixed<double, 3> f2_vq2 = 2.0*vq2 - vq3 - vq1;
				vnl_vector_fixed<double, 3> f2_vq3 = vq1 - vq2;

				vnl_vector_fixed<double, 3> f3_vq1 = vq2 - vq3;
				vnl_vector_fixed<double, 3> f3_vq2 = vq1 - vq3;
				vnl_vector_fixed<double, 3> f3_vq3 = 2.0*vq3 - vq2 - vq1;

				for (int i = 0; i<ngn_indices.size(); i++)
				{
					int ndIdx = ngn_indices[i];
					vnl_vector_fixed<double, 3> const& g_k = graph->nodes[ndIdx].g;
					double w1 = this->ngnWeights_vt1[i];
					double w2 = this->ngnWeights_vt2[i];
					double w3 = this->ngnWeights_vt3[i];
					vnl_vector_fixed<double, 3> tmp1 = this->vt1 - g_k;
					vnl_vector_fixed<double, 3> tmp2 = this->vt2 - g_k;
					vnl_vector_fixed<double, 3> tmp3 = this->vt3 - g_k;

					if (jacobians[6 * i] != NULL)
					{
						jacobians[6 * i][0] = w1*f1_vq1[0] * tmp1[0] + w2*f1_vq2[0] * tmp2[0] + w3*f1_vq3[0] * tmp3[0];
						jacobians[6 * i][1] = w1*f1_vq1[0] * tmp1[1] + w2*f1_vq2[0] * tmp2[1] + w3*f1_vq3[0] * tmp3[1];
						jacobians[6 * i][2] = w1*f1_vq1[0] * tmp1[2] + w2*f1_vq2[0] * tmp2[2] + w3*f1_vq3[0] * tmp3[2];

						jacobians[6 * i][3] = w1*f2_vq1[0] * tmp1[0] + w2*f2_vq2[0] * tmp2[0] + w3*f2_vq3[0] * tmp3[0];
						jacobians[6 * i][4] = w1*f2_vq1[0] * tmp1[1] + w2*f2_vq2[0] * tmp2[1] + w3*f2_vq3[0] * tmp3[1];
						jacobians[6 * i][5] = w1*f2_vq1[0] * tmp1[2] + w2*f2_vq2[0] * tmp2[2] + w3*f2_vq3[0] * tmp3[2];

						jacobians[6 * i][6] = w1*f3_vq1[0] * tmp1[0] + w2*f3_vq2[0] * tmp2[0] + w3*f3_vq3[0] * tmp3[0];
						jacobians[6 * i][7] = w1*f3_vq1[0] * tmp1[1] + w2*f3_vq2[0] * tmp2[1] + w3*f3_vq3[0] * tmp3[1];
						jacobians[6 * i][8] = w1*f3_vq1[0] * tmp1[2] + w2*f3_vq2[0] * tmp2[2] + w3*f3_vq3[0] * tmp3[2];
					}

					if (jacobians[6 * i + 1] != NULL)
					{
						jacobians[6 * i + 1][0] = w1*f1_vq1[1] * tmp1[0] + w2*f1_vq2[1] * tmp2[0] + w3*f1_vq3[1] * tmp3[0];
						jacobians[6 * i + 1][1] = w1*f1_vq1[1] * tmp1[1] + w2*f1_vq2[1] * tmp2[1] + w3*f1_vq3[1] * tmp3[1];
						jacobians[6 * i + 1][2] = w1*f1_vq1[1] * tmp1[2] + w2*f1_vq2[1] * tmp2[2] + w3*f1_vq3[1] * tmp3[2];

						jacobians[6 * i + 1][3] = w1*f2_vq1[1] * tmp1[0] + w2*f2_vq2[1] * tmp2[0] + w3*f2_vq3[1] * tmp3[0];
						jacobians[6 * i + 1][4] = w1*f2_vq1[1] * tmp1[1] + w2*f2_vq2[1] * tmp2[1] + w3*f2_vq3[1] * tmp3[1];
						jacobians[6 * i + 1][5] = w1*f2_vq1[1] * tmp1[2] + w2*f2_vq2[1] * tmp2[2] + w3*f2_vq3[1] * tmp3[2];

						jacobians[6 * i + 1][6] = w1*f3_vq1[1] * tmp1[0] + w2*f3_vq2[1] * tmp2[0] + w3*f3_vq3[1] * tmp3[0];
						jacobians[6 * i + 1][7] = w1*f3_vq1[1] * tmp1[1] + w2*f3_vq2[1] * tmp2[1] + w3*f3_vq3[1] * tmp3[1];
						jacobians[6 * i + 1][8] = w1*f3_vq1[1] * tmp1[2] + w2*f3_vq2[1] * tmp2[2] + w3*f3_vq3[1] * tmp3[2];
					}

					if (jacobians[6 * i + 2] != NULL)
					{
						jacobians[6 * i + 2][0] = w1*f1_vq1[2] * tmp1[0] + w2*f1_vq2[2] * tmp2[0] + w3*f1_vq3[2] * tmp3[0];
						jacobians[6 * i + 2][1] = w1*f1_vq1[2] * tmp1[1] + w2*f1_vq2[2] * tmp2[1] + w3*f1_vq3[2] * tmp3[1];
						jacobians[6 * i + 2][2] = w1*f1_vq1[2] * tmp1[2] + w2*f1_vq2[2] * tmp2[2] + w3*f1_vq3[2] * tmp3[2];

						jacobians[6 * i + 2][3] = w1*f2_vq1[2] * tmp1[0] + w2*f2_vq2[2] * tmp2[0] + w3*f2_vq3[2] * tmp3[0];
						jacobians[6 * i + 2][4] = w1*f2_vq1[2] * tmp1[1] + w2*f2_vq2[2] * tmp2[1] + w3*f2_vq3[2] * tmp3[1];
						jacobians[6 * i + 2][5] = w1*f2_vq1[2] * tmp1[2] + w2*f2_vq2[2] * tmp2[2] + w3*f2_vq3[2] * tmp3[2];

						jacobians[6 * i + 2][6] = w1*f3_vq1[2] * tmp1[0] + w2*f3_vq2[2] * tmp2[0] + w3*f3_vq3[2] * tmp3[0];
						jacobians[6 * i + 2][7] = w1*f3_vq1[2] * tmp1[1] + w2*f3_vq2[2] * tmp2[1] + w3*f3_vq3[2] * tmp3[1];
						jacobians[6 * i + 2][8] = w1*f3_vq1[2] * tmp1[2] + w2*f3_vq2[2] * tmp2[2] + w3*f3_vq3[2] * tmp3[2];
					}

					if (jacobians[6 * i + 3] != NULL)
					{
						jacobians[6 * i + 3][0] = w1*f1_vq1[0] + w2*f1_vq2[0] + w3*f1_vq3[0];

						jacobians[6 * i + 3][1] = w1*f2_vq1[0] + w2*f2_vq2[0] + w3*f2_vq3[0];

						jacobians[6 * i + 3][2] = w1*f3_vq1[0] + w2*f3_vq2[0] + w3*f3_vq3[0];
					}

					if (jacobians[6 * i + 4] != NULL)
					{
						jacobians[6 * i + 4][0] = w1*f1_vq1[1] + w2*f1_vq2[1] + w3*f1_vq3[1];

						jacobians[6 * i + 4][1] = w1*f2_vq1[1] + w2*f2_vq2[1] + w3*f2_vq3[1];

						jacobians[6 * i + 4][2] = w1*f3_vq1[1] + w2*f3_vq2[1] + w3*f3_vq3[1];
					}

					if (jacobians[6 * i + 5] != NULL)
					{
						jacobians[6 * i + 5][0] = w1*f1_vq1[2] + w2*f1_vq2[2] + w3*f1_vq3[2];

						jacobians[6 * i + 5][1] = w1*f2_vq1[2] + w2*f2_vq2[2] + w3*f2_vq3[2];

						jacobians[6 * i + 5][2] = w1*f3_vq1[2] + w2*f3_vq2[2] + w3*f3_vq3[2];
					}
				}
			}

			return true;
		}

	private:
		int graphIdx;
		int vtIdx1;
		int vtIdx2;
		int vtIdx3;

		vnl_vector_fixed<double, 3> vt1;
		vnl_vector_fixed<double, 3> vt2;
		vnl_vector_fixed<double, 3> vt3;

		vector<int> ngn_indices;
		vector<float> ngnWeights_vt1;
		vector<float> ngnWeights_vt2;
		vector<float> ngnWeights_vt3;

		//inner product of two edges of a triangular on the tangent plane
		double inner_prod_1;// two edges connected by vt1
		double inner_prod_2;// two edges connected by vt2
		double inner_prod_3;// two edges connected by vt3		

	};

	//randomly sample three vectors on tangent plane, and preserve their inner-products
	class F2 : public CostFunction, public DeformGraphOptMultiDataPlusStatic
	{
	public:
		F2(int graphIdx_, int vtIdx_)
		{
			assert(graphIdx_ < graphs.size() );
			this->graphIdx = graphIdx_;

			assert(vtIdx_ < surfaces[graphIdx]->vtNum );
			this->vtIdx = vtIdx_;
			this->ngn = &((*(ngns_dense[graphIdx]))[vtIdx_]);

			float *n_ = surfaces[graphIdx]->vt_data_block(vtIdx);
			vnl_vector_fixed<double, 3> n(n_[0], n_[1], n_[2]);
			n.normalize();
			vnl_vector_fixed<double, 3> f1(RANDOM-0.5, RANDOM-0.5, RANDOM-0.5);
			f1.normalize();
			vnl_vector_fixed<double, 3> f2 = cross_product(n, f1);
			f2.normalize();
			f1 = cross_product(f2, n);
			this->t1 = f1;
			this->t2 = -0.5*f1 + std::sqrt(3.0)/2.0*f2;
			this->t3 = -0.5*f1 - std::sqrt(3.0)/2.0*f2;		

			assert( dot_product(t1, t2) + 0.5 < 0.0001 );
			assert( dot_product(t2, t3) + 0.5 < 0.0001 );
			assert( dot_product(t1, t3) + 0.5 < 0.0001 );
			assert( dot_product(t1, n) < 0.0001 );
			assert( dot_product(t2, n) < 0.0001 );
			assert( dot_product(t3, n) < 0.0001 );
			
			this->set_num_residuals(3);
			for(int i=0; i<this->ngn->neighborIndices.size(); i++)
			{
				this->mutable_parameter_block_sizes()->push_back(3); //r0
				this->mutable_parameter_block_sizes()->push_back(3); //r1
				this->mutable_parameter_block_sizes()->push_back(3); //r2
			}
		}
		~F2(){};

	public:
		virtual bool Evaluate(double const* const* parameters,
					double* residuals,
					double** jacobians) const
		{
			DeformGraph *graph = graphs[graphIdx];

			vnl_vector_fixed<double, 3> tq1(0.0, 0.0, 0.0);
			vnl_vector_fixed<double, 3> tq2(0.0, 0.0, 0.0);
			vnl_vector_fixed<double, 3> tq3(0.0, 0.0, 0.0);
			for(int i=0; i<this->ngn->neighborIndices.size(); i++)
			{
				int ndIdx = this->ngn->neighborIndices[i];
				DeformGraphNode const& node = graph->nodes[ndIdx];
				tq1 += double(this->ngn->weights[i]) * node.A * this->t1;
				tq2 += double(this->ngn->weights[i]) * node.A * this->t2;
				tq3 += double(this->ngn->weights[i]) * node.A * this->t3;
			}

			residuals[0] = dot_product(tq1, tq2) + 0.5;
			residuals[1] = dot_product(tq1, tq3) + 0.5;
			residuals[2] = dot_product(tq2, tq3) + 0.5;

			if( jacobians != NULL )
			{
				for(int i=0; i<this->ngn->neighborIndices.size(); i++)
				{
					double w = this->ngn->weights[i];

					if( jacobians[3*i] != NULL )
					{
							jacobians[3*i][0] = w*tq2[0]*t1[0] + w*tq1[0]*t2[0];
							jacobians[3*i][1] = w*tq2[0]*t1[1] + w*tq1[0]*t2[1];
							jacobians[3*i][2] = w*tq2[0]*t1[2] + w*tq1[0]*t2[2];

						//d(f2)/d(r0)--- f2 = tq1*tq3+0.5
							jacobians[3*i][3] = w*tq3[0]*t1[0] + w*tq1[0]*t3[0];
							jacobians[3*i][4] = w*tq3[0]*t1[1] + w*tq1[0]*t3[1];
							jacobians[3*i][5] = w*tq3[0]*t1[2] + w*tq1[0]*t3[2];

						//d(f2)/d(r0)--- f3 = tq2*tq3+0.5						
							jacobians[3*i][6] = w*tq3[0]*t2[0] + w*tq2[0]*t3[0];
							jacobians[3*i][7] = w*tq3[0]*t2[1] + w*tq2[0]*t3[1];
							jacobians[3*i][8] = w*tq3[0]*t2[2] + w*tq2[0]*t3[2];
					}

					if( jacobians[3*i+1] != NULL )
					{

						//d(f1)/d(r1)---  f1 = tq1*tq2+0.5						
							jacobians[3*i+1][0] = w*tq2[1]*t1[0] + w*tq1[1]*t2[0];
							jacobians[3*i+1][1] = w*tq2[1]*t1[1] + w*tq1[1]*t2[1];
							jacobians[3*i+1][2] = w*tq2[1]*t1[2] + w*tq1[1]*t2[2];

						//d(f2)/d(r1)--- f2 = tq1*tq3+0.5							
							jacobians[3*i+1][3] = w*tq3[1]*t1[0] + w*tq1[1]*t3[0];
							jacobians[3*i+1][4] = w*tq3[1]*t1[1] + w*tq1[1]*t3[1];
							jacobians[3*i+1][5] = w*tq3[1]*t1[2] + w*tq1[1]*t3[2];

						//d(f3)/d(r1)--- f3 = tq2*tq3+0.5
							jacobians[3*i+1][6] = w*tq3[1]*t2[0] + w*tq2[1]*t3[0];
							jacobians[3*i+1][7] = w*tq3[1]*t2[1] + w*tq2[1]*t3[1];
							jacobians[3*i+1][8] = w*tq3[1]*t2[2] + w*tq2[1]*t3[2];
					}
				
					if( jacobians[3*i+2] != NULL )
					{

						//d(f1)/d(r2)---  f1 = tq1*tq2+0.5
							jacobians[3*i+2][0] = w*tq2[2]*t1[0] + w*tq1[2]*t2[0];
							jacobians[3*i+2][1] = w*tq2[2]*t1[1] + w*tq1[2]*t2[1];
							jacobians[3*i+2][2] = w*tq2[2]*t1[2] + w*tq1[2]*t2[2];

						//d(f2)/d(r2)---  f2 = tq1*tq3+0.5
							jacobians[3*i+2][3] = w*tq3[2]*t1[0] + w*tq1[2]*t3[0];
							jacobians[3*i+2][4] = w*tq3[2]*t1[1] + w*tq1[2]*t3[1];
							jacobians[3*i+2][5] = w*tq3[2]*t1[2] + w*tq1[2]*t3[2];

						//d(f3)/d(r2)---  f3 = tq2*tq3+0.5
							jacobians[3*i+2][6] = w*tq3[2]*t2[0] + w*tq2[2]*t3[0];
							jacobians[3*i+2][7] = w*tq3[2]*t2[1] + w*tq2[2]*t3[1];
							jacobians[3*i+2][8] = w*tq3[2]*t2[2] + w*tq2[2]*t3[2];
					}
				} //end of for-i
			}//end of if

			return true;
		}

	private:
		int graphIdx;
		int vtIdx;
		NeighborGraphNodesOfPoint *ngn;
		vnl_vector_fixed<double, 3> t1;
		vnl_vector_fixed<double, 3> t2;
		vnl_vector_fixed<double, 3> t3;
	};


	//parameters: [r0, r1, r2, t0, t1, t2; r0, r1, r2, t0, t1, t2; ...]
	class F3 : public CostFunction, public DeformGraphOptMultiDataPlusStatic
	{
	public:
		//ngn_indices_: the neighboring graph nodes of all three vertices
		F3(int graphIdx_, int vtIdx1_, int vtIdx2_, int vtIdx3_, vector<int> const& ngn_indices_ )
		{
			assert( graphIdx_ < graphs.size() );
			this->graphIdx = graphIdx_;

			assert( vtIdx1_ < DeformGraphOptMultiDataPlusStatic::surfaces[graphIdx]->vtNum);
			assert( vtIdx2_ < DeformGraphOptMultiDataPlusStatic::surfaces[graphIdx]->vtNum);
			assert( vtIdx3_ < DeformGraphOptMultiDataPlusStatic::surfaces[graphIdx]->vtNum);
			this->vtIdx1 = vtIdx1_;
			this->vtIdx2 = vtIdx2_;
			this->vtIdx3 = vtIdx3_;
			this->ngn_indices = ngn_indices_;

			float *p1 = surfaces[graphIdx]->vt_data_block(vtIdx1);
			float *p2 = surfaces[graphIdx]->vt_data_block(vtIdx2);
			float *p3 = surfaces[graphIdx]->vt_data_block(vtIdx3);
			this->vt1 = vnl_vector_fixed<double, 3>(p1[0], p1[1], p1[2]);
			this->vt2 = vnl_vector_fixed<double, 3>(p2[0], p2[1], p2[2]);
			this->vt3 = vnl_vector_fixed<double, 3>(p3[0], p3[1], p3[2]);
			float *n1_ = surfaces[graphIdx]->vt_normal(vtIdx1);
			float *n2_ = surfaces[graphIdx]->vt_normal(vtIdx2);
			float *n3_ = surfaces[graphIdx]->vt_normal(vtIdx3);
			this->n1 = vnl_vector_fixed<double, 3>(n1_[0], n1_[1], n1_[2]);
			this->n2 = vnl_vector_fixed<double, 3>(n2_[0], n2_[1], n2_[2]);
			this->n3 = vnl_vector_fixed<double, 3>(n3_[0], n3_[1], n3_[2]);

			vnl_vector_fixed<double, 3> e12 = vt2-vt1;
			vnl_vector_fixed<double, 3> e13 = vt3-vt1;
			vnl_vector_fixed<double, 3> e21 = vt1-vt2;
			vnl_vector_fixed<double, 3> e23 = vt3-vt2;
			vnl_vector_fixed<double, 3> e31 = vt1-vt3;
			vnl_vector_fixed<double, 3> e32 = vt2-vt3;

			inner_prod_1 = dot_product(e12, e13) - dot_product(e12, n1)*dot_product(e13, n1);
			inner_prod_2 = dot_product(e21, e23) - dot_product(e21, n2)*dot_product(e23, n2);
			inner_prod_3 = dot_product(e31, e32) - dot_product(e31, n3)*dot_product(e32, n3);


			vector<int> const& ngn_list1 = (*(ngns_dense[graphIdx]))[vtIdx1].neighborIndices;
			vector<double> const& ngn_weights1 = (*(ngns_dense[graphIdx]))[vtIdx1].weights;
			vector<int> const& ngn_list2 = (*(ngns_dense[graphIdx]))[vtIdx2].neighborIndices;
			vector<double> const& ngn_weights2 = (*(ngns_dense[graphIdx]))[vtIdx2].weights;
			vector<int> const& ngn_list3 = (*(ngns_dense[graphIdx]))[vtIdx3].neighborIndices;
			vector<double> const& ngn_weights3 = (*(ngns_dense[graphIdx]))[vtIdx3].weights;
			
			this->ngnWeights_vt1.resize(ngn_indices.size());
			this->ngnWeights_vt2.resize(ngn_indices.size());
			this->ngnWeights_vt3.resize(ngn_indices.size());
			for(int i=0; i<ngn_indices.size(); i++)
			{
				int ngnIdx = ngn_indices[i];
				assert(ngnIdx >=0 && ngnIdx < graphs[graphIdx]->nodes.size() );

				int index1 = search_val_list(ngn_list1, ngnIdx);
				if( index1==-1)
					ngnWeights_vt1[i] = 0.0;
				else
					ngnWeights_vt1[i] = ngn_weights1[index1];

				int index2 = search_val_list(ngn_list2, ngnIdx);
				if( index2==-1)
					ngnWeights_vt2[i] = 0.0;
				else
					ngnWeights_vt2[i] = ngn_weights2[index2];

				int index3 = search_val_list(ngn_list3, ngnIdx);
				if( index3==-1)
					ngnWeights_vt3[i] = 0.0;
				else
					ngnWeights_vt3[i] = ngn_weights3[index3];
			}

			this->set_num_residuals(3);
			for(int i=0; i<ngn_indices.size(); i++)
			{
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
			}
		}
		~F3(){};

	public:
		virtual bool Evaluate(double const* const* parameters,
					double* residuals,
					double** jacobians) const
		{
			CSurface<float> const& surface_t = surfaces_t[graphIdx];
			DeformGraph *graph = graphs[graphIdx];

			float const* q1 = surface_t.vt_data_block(this->vtIdx1);
			float const* q2 = surface_t.vt_data_block(this->vtIdx2);
			float const* q3 = surface_t.vt_data_block(this->vtIdx3);
			vnl_vector_fixed<double, 3> vq1(q1[0], q1[1], q1[2]);
			vnl_vector_fixed<double, 3> vq2(q2[0], q2[1], q2[2]);
			vnl_vector_fixed<double, 3> vq3(q3[0], q3[1], q3[2]);
			float const* nq1_ = surface_t.vt_normal(this->vtIdx1);
			float const* nq2_ = surface_t.vt_normal(this->vtIdx2);
			float const* nq3_ = surface_t.vt_normal(this->vtIdx3);
			vnl_vector_fixed<double, 3> nq1(nq1_[0], nq1_[1], nq1_[2]);
			vnl_vector_fixed<double, 3> nq2(nq2_[0], nq2_[1], nq2_[2]);
			vnl_vector_fixed<double, 3> nq3(nq3_[0], nq3_[1], nq3_[2]);

			vnl_vector_fixed<double, 3> e12 = vq2-vq1;
			vnl_vector_fixed<double, 3> e13 = vq3-vq1;
			vnl_vector_fixed<double, 3> e21 = vq1-vq2;
			vnl_vector_fixed<double, 3> e23 = vq3-vq2;
			vnl_vector_fixed<double, 3> e31 = vq1-vq3;
			vnl_vector_fixed<double, 3> e32 = vq2-vq3;

			residuals[0] = dot_product(e12, e13) - dot_product(e12, nq1)*dot_product(e13, nq1) - inner_prod_1;
			residuals[1] = dot_product(e21, e23) - dot_product(e21, nq2)*dot_product(e23, nq2) - inner_prod_2;
			residuals[2] = dot_product(e31, e32) - dot_product(e31, nq3)*dot_product(e32, nq3) - inner_prod_3;

			if( jacobians != NULL )
			{
				vnl_vector_fixed<double, 3> f1_vq1 = 2.0*vq1-vq2-vq3;
				vnl_vector_fixed<double, 3> f1_vq2 = vq3-vq1;
				vnl_vector_fixed<double, 3> f1_vq3 = vq2-vq1;
				vnl_vector_fixed<double, 3> f1_nq1 = -(dot_product(nq1, e12)*e13 + dot_product(nq1, e13)*e12);

				vnl_vector_fixed<double, 3> f2_vq1 = vq3-vq2;
				vnl_vector_fixed<double, 3> f2_vq2 = 2.0*vq2-vq3-vq1;
				vnl_vector_fixed<double, 3> f2_vq3 = vq1-vq2;
				vnl_vector_fixed<double, 3> f2_nq2 = -(dot_product(nq2, e21)*e23 + dot_product(nq2, e23)*e21);

				vnl_vector_fixed<double, 3> f3_vq1 = vq2-vq3;
				vnl_vector_fixed<double, 3> f3_vq2 = vq1-vq3;
				vnl_vector_fixed<double, 3> f3_vq3 = 2.0*vq3-vq2-vq1;
				vnl_vector_fixed<double, 3> f3_nq3 = -(dot_product(nq3, e31)*e32 + dot_product(nq3, e32)*e31);

				for(int i=0; i<ngn_indices.size(); i++)
				{
					int ndIdx = ngn_indices[i];
					vnl_vector_fixed<double, 3> const& g_k = graph->nodes[ndIdx].g;
					double w1 = this->ngnWeights_vt1[i];
					double w2 = this->ngnWeights_vt2[i];
					double w3 = this->ngnWeights_vt3[i];
					vnl_vector_fixed<double, 3> tmp1 = this->vt1-g_k;
					vnl_vector_fixed<double, 3> tmp2 = this->vt2-g_k;
					vnl_vector_fixed<double, 3> tmp3 = this->vt3-g_k;

					vnl_matrix_fixed<double, 3, 3> const& A = graph->nodes[ndIdx].A;
					vnl_matrix_fixed<double, 3, 3> A_inv = vnl_inverse(A);
					vnl_matrix_fixed<double, 3, 3> dA_inv[9];
					for(int j=0; j<3; j++){
						for(int k=0; k<3; k++){
							vnl_matrix_fixed<double, 3, 3> dA;
							dA.fill(0.0);
							dA(j, k) = 1.0;
							dA_inv[j*3+k] = -A_inv*dA*A_inv;
						}
					}

					if( jacobians[6*i] != NULL)
					{
						//df1/dr0
							jacobians[6*i][0] = w1*f1_vq1[0]*tmp1[0] + w2*f1_vq2[0]*tmp2[0] + w3*f1_vq3[0]*tmp3[0] + w1*dot_product(f1_nq1, dA_inv[0]*n1);
							jacobians[6*i][1] = w1*f1_vq1[0]*tmp1[1] + w2*f1_vq2[0]*tmp2[1] + w3*f1_vq3[0]*tmp3[1] + w1*dot_product(f1_nq1, dA_inv[1]*n1);
							jacobians[6*i][2] = w1*f1_vq1[0]*tmp1[2] + w2*f1_vq2[0]*tmp2[2] + w3*f1_vq3[0]*tmp3[2] + w1*dot_product(f1_nq1, dA_inv[2]*n1);

						//df2/dr0
							jacobians[6*i][3] = w1*f2_vq1[0]*tmp1[0] + w2*f2_vq2[0]*tmp2[0] + w3*f2_vq3[0]*tmp3[0] + w2*dot_product(f2_nq2, dA_inv[0]*n2);
							jacobians[6*i][4] = w1*f2_vq1[0]*tmp1[1] + w2*f2_vq2[0]*tmp2[1] + w3*f2_vq3[0]*tmp3[1] + w2*dot_product(f2_nq2, dA_inv[1]*n2);
							jacobians[6*i][5] = w1*f2_vq1[0]*tmp1[2] + w2*f2_vq2[0]*tmp2[2] + w3*f2_vq3[0]*tmp3[2] + w2*dot_product(f2_nq2, dA_inv[2]*n2);
						
						//df3/dr0
							jacobians[6*i][6] = w1*f3_vq1[0]*tmp1[0] + w2*f3_vq2[0]*tmp2[0] + w3*f3_vq3[0]*tmp3[0] + w3*dot_product(f3_nq3, dA_inv[0]*n3);
							jacobians[6*i][7] = w1*f3_vq1[0]*tmp1[1] + w2*f3_vq2[0]*tmp2[1] + w3*f3_vq3[0]*tmp3[1] + w3*dot_product(f3_nq3, dA_inv[1]*n3);
							jacobians[6*i][8] = w1*f3_vq1[0]*tmp1[2] + w2*f3_vq2[0]*tmp2[2] + w3*f3_vq3[0]*tmp3[2] + w3*dot_product(f3_nq3, dA_inv[2]*n3);
					}

					if( jacobians[6*i+1] != NULL)
					{
						//df1/dr1
							jacobians[6*i+1][0] = w1*f1_vq1[1]*tmp1[0] + w2*f1_vq2[1]*tmp2[0] + w3*f1_vq3[1]*tmp3[0] + w1*dot_product(f1_nq1, dA_inv[3]*n1);
							jacobians[6*i+1][1] = w1*f1_vq1[1]*tmp1[1] + w2*f1_vq2[1]*tmp2[1] + w3*f1_vq3[1]*tmp3[1] + w1*dot_product(f1_nq1, dA_inv[4]*n1);
							jacobians[6*i+1][2] = w1*f1_vq1[1]*tmp1[2] + w2*f1_vq2[1]*tmp2[2] + w3*f1_vq3[1]*tmp3[2] + w1*dot_product(f1_nq1, dA_inv[5]*n1);											
						
						//df2/dr1
							jacobians[6*i+1][3] = w1*f2_vq1[1]*tmp1[0] + w2*f2_vq2[1]*tmp2[0] + w3*f2_vq3[1]*tmp3[0] + w2*dot_product(f2_nq2, dA_inv[3]*n2);
							jacobians[6*i+1][4] = w1*f2_vq1[1]*tmp1[1] + w2*f2_vq2[1]*tmp2[1] + w3*f2_vq3[1]*tmp3[1] + w2*dot_product(f2_nq2, dA_inv[4]*n2);
							jacobians[6*i+1][5] = w1*f2_vq1[1]*tmp1[2] + w2*f2_vq2[1]*tmp2[2] + w3*f2_vq3[1]*tmp3[2] + w2*dot_product(f2_nq2, dA_inv[5]*n2);

						//df3/dr1	
							jacobians[6*i+1][6] = w1*f3_vq1[1]*tmp1[0] + w2*f3_vq2[1]*tmp2[0] + w3*f3_vq3[1]*tmp3[0] + w3*dot_product(f3_nq3, dA_inv[3]*n3);
							jacobians[6*i+1][7] = w1*f3_vq1[1]*tmp1[1] + w2*f3_vq2[1]*tmp2[1] + w3*f3_vq3[1]*tmp3[1] + w3*dot_product(f3_nq3, dA_inv[4]*n3);
							jacobians[6*i+1][8] = w1*f3_vq1[1]*tmp1[2] + w2*f3_vq2[1]*tmp2[2] + w3*f3_vq3[1]*tmp3[2] + w3*dot_product(f3_nq3, dA_inv[5]*n3);
					}

					if( jacobians[6*i+2] != NULL)
					{
						//df1/dr2
							jacobians[6*i+2][0] = w1*f1_vq1[2]*tmp1[0] + w2*f1_vq2[2]*tmp2[0] + w3*f1_vq3[2]*tmp3[0] + w1*dot_product(f1_nq1, dA_inv[6]*n1);
							jacobians[6*i+2][1] = w1*f1_vq1[2]*tmp1[1] + w2*f1_vq2[2]*tmp2[1] + w3*f1_vq3[2]*tmp3[1] + w1*dot_product(f1_nq1, dA_inv[7]*n1);
							jacobians[6*i+2][2] = w1*f1_vq1[2]*tmp1[2] + w2*f1_vq2[2]*tmp2[2] + w3*f1_vq3[2]*tmp3[2] + w1*dot_product(f1_nq1, dA_inv[8]*n1);

						//df2/dr2
							jacobians[6*i+2][3] = w1*f2_vq1[2]*tmp1[0] + w2*f2_vq2[2]*tmp2[0] + w3*f2_vq3[2]*tmp3[0] + w2*dot_product(f2_nq2, dA_inv[6]*n2);
							jacobians[6*i+2][4] = w1*f2_vq1[2]*tmp1[1] + w2*f2_vq2[2]*tmp2[1] + w3*f2_vq3[2]*tmp3[1] + w2*dot_product(f2_nq2, dA_inv[7]*n2);
							jacobians[6*i+2][5] = w1*f2_vq1[2]*tmp1[2] + w2*f2_vq2[2]*tmp2[2] + w3*f2_vq3[2]*tmp3[2] + w2*dot_product(f2_nq2, dA_inv[8]*n2);

						//df3/dr2
							jacobians[6*i+2][6] = w1*f3_vq1[2]*tmp1[0] + w2*f3_vq2[2]*tmp2[0] + w3*f3_vq3[2]*tmp3[0] + w3*dot_product(f3_nq3, dA_inv[6]*n3);
							jacobians[6*i+2][7] = w1*f3_vq1[2]*tmp1[1] + w2*f3_vq2[2]*tmp2[1] + w3*f3_vq3[2]*tmp3[1] + w3*dot_product(f3_nq3, dA_inv[7]*n3);
							jacobians[6*i+2][8] = w1*f3_vq1[2]*tmp1[2] + w2*f3_vq2[2]*tmp2[2] + w3*f3_vq3[2]*tmp3[2] + w3*dot_product(f3_nq3, dA_inv[8]*n3);
					}

					if( jacobians[6*i+3] != NULL )
					{
						//df1/dt0
							jacobians[6*i+3][0] = w1*f1_vq1[0] + w2*f1_vq2[0] + w3*f1_vq3[0];

						//df2/dt0
							jacobians[6*i+3][1] = w1*f2_vq1[0] + w2*f2_vq2[0] + w3*f2_vq3[0];

						//df3/dt0
							jacobians[6*i+3][2] = w1*f3_vq1[0] + w2*f3_vq2[0] + w3*f3_vq3[0];
					}

					if( jacobians[6*i+4] != NULL )
					{
						//df1/dt1
							jacobians[6*i+4][0] = w1*f1_vq1[1] + w2*f1_vq2[1] + w3*f1_vq3[1];

						//df2/dt1
							jacobians[6*i+4][1] = w1*f2_vq1[1] + w2*f2_vq2[1] + w3*f2_vq3[1];

						//df3/dt1
							jacobians[6*i+4][2] = w1*f3_vq1[1] + w2*f3_vq2[1] + w3*f3_vq3[1];
					}

					if( jacobians[6*i+5] != NULL )
					{
						//df1/dt2
							jacobians[6*i+5][0] = w1*f1_vq1[2] + w2*f1_vq2[2] + w3*f1_vq3[2];

						//df2/dt2
							jacobians[6*i+5][1] = w1*f2_vq1[2] + w2*f2_vq2[2] + w3*f2_vq3[2];

						//df3/dt2
							jacobians[6*i+5][2] = w1*f3_vq1[2] + w2*f3_vq2[2] + w3*f3_vq3[2];
					}
				}
			}

			return true;
		}

	private:
		int graphIdx;
		int vtIdx1;
		int vtIdx2;
		int vtIdx3;

		vnl_vector_fixed<double, 3> vt1;
		vnl_vector_fixed<double, 3> vt2;
		vnl_vector_fixed<double, 3> vt3;
		vnl_vector_fixed<double, 3> n1;
		vnl_vector_fixed<double, 3> n2;
		vnl_vector_fixed<double, 3> n3;

		vector<int> ngn_indices;
		vector<float> ngnWeights_vt1;
		vector<float> ngnWeights_vt2;
		vector<float> ngnWeights_vt3;

		//inner product of two edges of a triangular on the tangent plane
		double inner_prod_1;// two edges connected by vt1
		double inner_prod_2;// two edges connected by vt2
		double inner_prod_3;// two edges connected by vt3		

	};

	//parameters: [r0, r1, r2, t0, t1, t2; r0, r1, r2, t0, t1, t2; ...]
	class F4 : public CostFunction, public DeformGraphOptMultiDataPlusStatic
	{
	public:
		//ngn_indices_: the neighboring graph nodes of two vertices
		F4(int graphIdx_, int vtIdx1_, int vtIdx2_, vector<int> const& ngn_indices_)
		{
			assert(graphIdx_ < graphs.size());
			this->graphIdx = graphIdx_;

			assert(vtIdx1_ < DeformGraphOptMultiDataPlusStatic::surfaces[graphIdx]->vtNum);
			assert(vtIdx2_ < DeformGraphOptMultiDataPlusStatic::surfaces[graphIdx]->vtNum);
			this->vtIdx1 = vtIdx1_;
			this->vtIdx2 = vtIdx2_;
			this->ngn_indices = ngn_indices_;

			float *p1 = surfaces[graphIdx]->vt_data_block(vtIdx1);
			float *p2 = surfaces[graphIdx]->vt_data_block(vtIdx2);
			this->vt1 = vnl_vector_fixed<double, 3>(p1[0], p1[1], p1[2]);
			this->vt2 = vnl_vector_fixed<double, 3>(p2[0], p2[1], p2[2]);

			this->len_sqr = dot_product(vt1 - vt2, vt1 - vt2);

			vector<int> const& ngn_list1 = (*(ngns_dense[graphIdx]))[vtIdx1].neighborIndices;
			vector<double> const& ngn_weights1 = (*(ngns_dense[graphIdx]))[vtIdx1].weights;
			vector<int> const& ngn_list2 = (*(ngns_dense[graphIdx]))[vtIdx2].neighborIndices;
			vector<double> const& ngn_weights2 = (*(ngns_dense[graphIdx]))[vtIdx2].weights;

			this->ngnWeights_vt1.resize(ngn_indices.size());
			this->ngnWeights_vt2.resize(ngn_indices.size());
			for (int i = 0; i<ngn_indices.size(); i++)
			{
				int ngnIdx = ngn_indices[i];
				assert(ngnIdx >= 0 && ngnIdx < graphs[graphIdx]->nodes.size());

				int index1 = search_val_list(ngn_list1, ngnIdx);
				if (index1 == -1)
					ngnWeights_vt1[i] = 0.0;
				else
					ngnWeights_vt1[i] = ngn_weights1[index1];

				int index2 = search_val_list(ngn_list2, ngnIdx);
				if (index2 == -1)
					ngnWeights_vt2[i] = 0.0;
				else
					ngnWeights_vt2[i] = ngn_weights2[index2];
			}

			this->set_num_residuals(1);
			for (int i = 0; i<ngn_indices.size(); i++)
			{
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
			}
		}
		~F4(){};

	public:
		virtual bool Evaluate(double const* const* parameters,
			double* residuals,
			double** jacobians) const
		{
			CSurface<float> const& surface_t = surfaces_t[graphIdx];
			DeformGraph *graph = graphs[graphIdx];

			const float* q1 = surface_t.vt_data_block(this->vtIdx1);
			const float* q2 = surface_t.vt_data_block(this->vtIdx2);
			vnl_vector_fixed<double, 3> vq1(q1[0], q1[1], q1[2]);
			vnl_vector_fixed<double, 3> vq2(q2[0], q2[1], q2[2]);

			residuals[0] = dot_product(vq1 - vq2, vq1 - vq2) - len_sqr;

			if (jacobians != NULL)
			{
				vnl_vector_fixed<double, 3> f1_vq1 = 2.0*(vq1 - vq2);
				vnl_vector_fixed<double, 3> f1_vq2 = vq2-vq1;

				for (int i = 0; i<ngn_indices.size(); i++)
				{
					int ndIdx = ngn_indices[i];
					vnl_vector_fixed<double, 3> const& g_k = graph->nodes[ndIdx].g;
					double w1 = this->ngnWeights_vt1[i];
					double w2 = this->ngnWeights_vt2[i];
					vnl_vector_fixed<double, 3> tmp1 = this->vt1 - g_k;
					vnl_vector_fixed<double, 3> tmp2 = this->vt2 - g_k;

					if (jacobians[6 * i] != NULL)
					{
						jacobians[6 * i][0] = w1*f1_vq1[0] * tmp1[0] + w2*f1_vq2[0] * tmp2[0];
						jacobians[6 * i][1] = w1*f1_vq1[0] * tmp1[1] + w2*f1_vq2[0] * tmp2[1];
						jacobians[6 * i][2] = w1*f1_vq1[0] * tmp1[2] + w2*f1_vq2[0] * tmp2[2];
					}

					if (jacobians[6 * i + 1] != NULL)
					{
						jacobians[6 * i + 1][0] = w1*f1_vq1[1] * tmp1[0] + w2*f1_vq2[1] * tmp2[0];
						jacobians[6 * i + 1][1] = w1*f1_vq1[1] * tmp1[1] + w2*f1_vq2[1] * tmp2[1];
						jacobians[6 * i + 1][2] = w1*f1_vq1[1] * tmp1[2] + w2*f1_vq2[1] * tmp2[2];

					}

					if (jacobians[6 * i + 2] != NULL)
					{
						jacobians[6 * i + 2][0] = w1*f1_vq1[2] * tmp1[0] + w2*f1_vq2[2] * tmp2[0];
						jacobians[6 * i + 2][1] = w1*f1_vq1[2] * tmp1[1] + w2*f1_vq2[2] * tmp2[1];
						jacobians[6 * i + 2][2] = w1*f1_vq1[2] * tmp1[2] + w2*f1_vq2[2] * tmp2[2];
					}

					if (jacobians[6 * i + 3] != NULL)
					{
						jacobians[6 * i + 3][0] = w1*f1_vq1[0] + w2*f1_vq2[0];
					}

					if (jacobians[6 * i + 4] != NULL)
					{
						jacobians[6 * i + 4][0] = w1*f1_vq1[1] + w2*f1_vq2[1];
					}

					if (jacobians[6 * i + 5] != NULL)
					{
						jacobians[6 * i + 5][0] = w1*f1_vq1[2] + w2*f1_vq2[2];
					}
				}
			}

			return true;
		}

	private:
		int graphIdx;
		int vtIdx1;
		int vtIdx2;

		vnl_vector_fixed<double, 3> vt1;
		vnl_vector_fixed<double, 3> vt2;

		vector<int> ngn_indices;
		vector<float> ngnWeights_vt1;
		vector<float> ngnWeights_vt2;

		double len_sqr;

	};
};

namespace RigidDensePtsTerm
{
	//parameters [rod, t]
	class F : public SizedCostFunction<1, 3, 3>, public DeformGraphOptMultiDataPlusStatic
	{
	public: 
		F(int robjIdx_, int vtIdx_)
		{
			assert(robjIdx_ < rigid_transfs.size());
			this->robjIdx = robjIdx_;
			assert(vtIdx_ < rigid_surfaces[robjIdx]->vtNum );
			this->vtIdx = vtIdx_;	

			this->p = rigid_surfaces[robjIdx]->vt_data_block(vtIdx);
		};
		~F(){};

	public:
		virtual bool Evaluate(double const* const* parameters,
					double* residuals,
					double** jacobians) const
		{
			vnl_vector_fixed<double, 3> &rod = rigid_transfs[robjIdx]->rod;

			float const* q = rigid_surfaces_t[robjIdx].vt_data_block(vtIdx);
			vnl_vector_fixed<double, 3> vq(q[0], q[1], q[2]);
			float const* nq_ = rigid_surfaces_t[robjIdx].vt_normal(vtIdx);
			vnl_vector_fixed<double, 3> nq(nq_[0], nq_[1], nq_[2]);

			residuals[0] = sdf_target->val_at(vq.data_block(), NULL, 0.0);
			// df/d(vt)
			vnl_vector_fixed<double, 3> der = sdf_target->der_at(vq.data_block(), nq.data_block(), 75);
			if (der[0] == 0.0 && der[1] == 0.0 && der[2] == 0.0)
				residuals[0] = 0.0;

			if( jacobians != NULL )
			{				
				//d(vq)/d(R)
				vnl_matrix<double> dvq_dR(3, 9);
				dvq_dR.fill(0.0);
				dvq_dR[0][0] = p[0]; dvq_dR[0][1] = p[1]; dvq_dR[0][2] = p[2];
				dvq_dR[1][3] = p[0]; dvq_dR[1][4] = p[1]; dvq_dR[1][5] = p[2];
				dvq_dR[2][6] = p[0]; dvq_dR[2][7] = p[1]; dvq_dR[2][8] = p[2];

				//d(R)/d(rod)
				vnl_matrix<double> dR_drod(9, 3);
				cv::Mat dR_drod_cv = cv::Mat(9, 3, CV_64F, dR_drod.data_block());
				cv::Mat rod_cv = cv::Mat(1, 3, CV_64F, rod.data_block());
				vnl_matrix_fixed<double, 3, 3> R;
				cv::Mat R_cv = cv::Mat(3, 3, CV_64F, R.data_block());
				cv::Rodrigues(rod_cv, R_cv, dR_drod_cv);			
			
				//d(vq)/d(rod)
				vnl_matrix_fixed<double, 3, 3> dvq_drod = dvq_dR * dR_drod;
				//d(f)/d(rod)
				vnl_vector_fixed<double, 3> jac = der * dvq_drod;
				if( jacobians[0] != NULL )
				{
					jacobians[0][0] = jac[0]; jacobians[0][1] = jac[1]; jacobians[0][2] = jac[2];
				}
				if(jacobians[1] != NULL )
				{
					jacobians[1][0] = der[0]; jacobians[1][1] = der[1]; jacobians[1][2] = der[2];
				}
			}
			return true;
		}

	private:
		int robjIdx;
		int vtIdx;
		float* p;
	};
};

namespace DensePtsTerm{
	//parameters: [r0, r1, r2, t0, t1, t2; r0, r1, r2, t0, t1, t2; ...]
	class F : public CostFunction, public DeformGraphOptMultiDataPlusStatic
	{
	public:
		F(int graphIdx_, int vtIdx_)
		{
			assert(graphIdx_<graphs.size());
			this->graphIdx = graphIdx_;

			assert(vtIdx_<surfaces[graphIdx]->vtNum);
			this->ngn = &((*(ngns_dense[graphIdx]))[vtIdx_]);
			this->v = surfaces[graphIdx]->vt_data_block(vtIdx_);
			//this->n = surface->vt_normal(vtIdx_);
			this->vtIdx = vtIdx_;

			this->set_num_residuals(1);
			int ngn_num = this->ngn->neighborIndices.size();
			for(int i=0; i<ngn_num; i++)
			{
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
			}
		}
		~F() {};

	public:
		virtual bool Evaluate(double const* const* parameters,
					double* residuals,
					double** jacobians) const
		{
			CSurface<float> const& surface_t = surfaces_t[graphIdx];
			DeformGraph *graph = graphs[graphIdx];
			int ngn_num = this->ngn->neighborIndices.size();

			const float *q2 = surface_t.vt_data_block(vtIdx);
			const float *n_t2 = surface_t.vt_normal(vtIdx);
			double q2_[3];
			q2_[0] = q2[0];
			q2_[1] = q2[1];
			q2_[2] = q2[2];
			double n_t2_[3];
			n_t2_[0] = n_t2[0];
			n_t2_[1] = n_t2[1];
			n_t2_[2] = n_t2[2];
			if( sdf_vals_last_retrieved_dynamic_surfs.size() > this->graphIdx && 
				sdf_vals_last_retrieved_dynamic_surfs[this->graphIdx] != NULL )
			{
				residuals[0] = sdf_target->val_at(q2_, NULL, sdf_vals_last_retrieved_dynamic_surfs[this->graphIdx][this->vtIdx]);
				sdf_vals_last_retrieved_dynamic_surfs[this->graphIdx][this->vtIdx] = residuals[0];
			}
			else
				residuals[0] = sdf_target->val_at(q2_, NULL);

			if( jacobians != NULL )
			{
				vnl_vector_fixed<double, 3> der = sdf_target->der_at(q2_, n_t2_, 60);
				for(int i=0; i<ngn_num; i++)
				{
					int ndIdx = this->ngn->neighborIndices[i];
					double w = this->ngn->weights[i];
					vnl_vector_fixed<double, 3> const& g_k = graph->nodes[ndIdx].g;
					vnl_vector_fixed<double, 3> tmp( v[0]-g_k[0], 
													 v[1]-g_k[1], 
													 v[2]-g_k[2]);

					if( jacobians[6*i] != NULL )
					{
						jacobians[6*i][0] = tmp[0]*der[0]*w;
						jacobians[6*i][1] = tmp[1]*der[0]*w;
						jacobians[6*i][2] = tmp[2]*der[0]*w;
					}
					if( jacobians[6*i+1] != NULL )
					{
						jacobians[6*i+1][0] = tmp[0]*der[1]*w;
						jacobians[6*i+1][1] = tmp[1]*der[1]*w;
						jacobians[6*i+1][2] = tmp[2]*der[1]*w;
					}
					if( jacobians[6*i+2] != NULL )
					{
						jacobians[6*i+2][0] = tmp[0]*der[2]*w;
						jacobians[6*i+2][1] = tmp[1]*der[2]*w;
						jacobians[6*i+2][2] = tmp[2]*der[2]*w;
					}
				
					if( jacobians[6*i+3] != NULL )
						jacobians[6*i+3][0] = der[0]*w;
					if( jacobians[6*i+4] != NULL )
						jacobians[6*i+4][0] = der[1]*w;
					if( jacobians[6*i+5] != NULL )
						jacobians[6*i+5][0] = der[2]*w;
				}
			}

			return true;
		}

	private:
		NeighborGraphNodesOfPoint *ngn;
		float* v;
		int graphIdx;
		int vtIdx;
	};

	//parameters: [r0, r1, r2, t0, t1, t2; r0, r1, r2, t0, t1, t2; ...] & [rod_global, t_global]
	class F2 : public CostFunction, public DeformGraphOptMultiDataPlusStatic
	{
	public:
		F2(int graphIdx_, int vtIdx_)
		{
			assert(graphIdx_<graphs.size());
			this->graphIdx = graphIdx_;

			assert(vtIdx_<surfaces[graphIdx]->vtNum);
			this->ngn = &((*(ngns_dense[graphIdx]))[vtIdx_]);
			this->v = surfaces[graphIdx]->vt_data_block(vtIdx_);
			this->vtIdx = vtIdx_;

			this->set_num_residuals(1);
			int ngn_num = this->ngn->neighborIndices.size();
			for (int i = 0; i<ngn_num; i++)
			{
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
			}
			this->mutable_parameter_block_sizes()->push_back(3);
			this->mutable_parameter_block_sizes()->push_back(3);
		}
		~F2() {};

	public:
		virtual bool Evaluate(double const* const* parameters,
			double* residuals,
			double** jacobians) const
		{
			CSurface<float> const& surface_t = surfaces_t[graphIdx];
			int ngn_num = this->ngn->neighborIndices.size();
			DeformGraph const* graph = this->graphs[graphIdx];

			vnl_vector_fixed<double, 3> const& T_global = graph->global_rigid.t;
			vnl_vector_fixed<double, 3> rod_global = graph->global_rigid.rod;
			vnl_matrix_fixed<double, 3, 3> R_global(0.0);
			//d(R)/d(rod)
			vnl_matrix_fixed<double, 9, 3> dR_drod(0.0);

			cv::Mat dR_drod_cv = cv::Mat(9, 3, CV_64F, dR_drod.data_block());
			cv::Mat rod_cv = cv::Mat(1, 3, CV_64F, &rod_global[0]);
			cv::Mat R_cv = cv::Mat(3, 3, CV_64F, R_global.data_block());
			cv::Rodrigues(rod_cv, R_cv, dR_drod_cv);

			vnl_vector_fixed<double, 3> vt(v[0], v[1], v[2]);
			float const* vt_t_ = surface_t.vt_data_block(vtIdx);
			vnl_vector_fixed<double, 3> vt_t(vt_t_[0], vt_t_[1], vt_t_[2]);
			float const* n_t_ = surface_t.vt_normal(vtIdx);
			vnl_vector_fixed<double, 3> n_t(n_t_[0], n_t_[1], n_t_[2]);

			residuals[0] = sdf_target->val_at(vt_t.data_block(), NULL, 1.0);

			vnl_vector_fixed<double, 3> df_dvtt = sdf_target->der_at(vt_t.data_block(), n_t.data_block(), 75);			
			vnl_vector_fixed<double, 3> df_dvttn = df_dvtt * R_global;

			vnl_vector_fixed<double, 3> vp_tn(0.0); //nonrigidly transformed point
			for (int i = 0; i<ngn_num; i++)
			{
				int ndIdx = this->ngn->neighborIndices[i];
				double w_k = this->ngn->weights[i];
				vnl_matrix_fixed<double, 3, 3> const& A_k = graph->nodes[ndIdx].A;
				vnl_vector_fixed<double, 3> const&t_k = graph->nodes[ndIdx].t;
				vnl_vector_fixed<double, 3> const& g_k = graph->nodes[ndIdx].g;

				vnl_vector_fixed<double, 3> tmp;
				tmp[0] = vt[0] - g_k[0];
				tmp[1] = vt[1] - g_k[1];
				tmp[2] = vt[2] - g_k[2];

				vp_tn += (A_k *tmp + g_k + t_k)*w_k;

				if (jacobians != NULL)
				{
					double w = w_k;
					if (jacobians[6 * i] != NULL)
					{
						//df0/dr0
						jacobians[6 * i][0] = df_dvttn[0]*tmp[0] * w_k;
						jacobians[6 * i][1] = df_dvttn[0]*tmp[1] * w_k;
						jacobians[6 * i][2] = df_dvttn[0]*tmp[2] * w_k;
					}
					if (jacobians[6 * i + 1] != NULL)
					{
						//df0/dr1
						jacobians[6 * i + 1][0] = df_dvttn[1]*tmp[0] * w_k;
						jacobians[6 * i + 1][1] = df_dvttn[1]*tmp[1] * w_k;
						jacobians[6 * i + 1][2] = df_dvttn[1]*tmp[2] * w_k;
					}
					if (jacobians[6 * i + 2] != NULL)
					{
						//df0/dr2
						jacobians[6 * i + 2][0] = df_dvttn[2]*tmp[0] * w_k;
						jacobians[6 * i + 2][1] = df_dvttn[2]*tmp[1] * w_k;
						jacobians[6 * i + 2][2] = df_dvttn[2]*tmp[2] * w_k;
					}

					if (jacobians[6 * i + 3] != NULL)
					{
						//df0/dt0
						jacobians[6 * i + 3][0] = df_dvttn[0]*w_k;
					}
					if (jacobians[6 * i + 4] != NULL)
					{
						//df0/dt1
						jacobians[6 * i + 4][0] = df_dvttn[1]*w_k;
					}
					if (jacobians[6 * i + 5] != NULL)
					{
						//df0/dt2
						jacobians[6 * i + 5][0] = df_dvttn[2]*w_k;
					}
				}
			}

			if (jacobians != NULL)
			{
				if (jacobians[6 * ngn_num] != NULL)
				{
					vnl_matrix_fixed<double, 3, 9> dvtt_dR(0.0);
					for (int i = 0; i < 3; i++)
					{
						dvtt_dR(0, i) = vp_tn[i];
						dvtt_dR(1, 3 + i) = vp_tn[i];
						dvtt_dR(2, 6 + i) = vp_tn[i];
					}
					vnl_vector_fixed<double, 9> df_dR = df_dvtt * dvtt_dR;
					vnl_vector_fixed<double, 3> df_drod = df_dR * dR_drod;

					memcpy(jacobians[6 * ngn_num], df_drod.data_block(), 3 * sizeof(double));
				}

				if (jacobians[6 * ngn_num + 1] != NULL)
				{
					//df0/dt
					jacobians[6 * ngn_num + 1][0] = df_dvtt[0];
					jacobians[6 * ngn_num + 1][1] = df_dvtt[1];
					jacobians[6 * ngn_num + 1][2] = df_dvtt[2];
				}
			}
			return true;
		}

	private:
		NeighborGraphNodesOfPoint *ngn;
		float* v;
		//float* n;
		int graphIdx;
		int vtIdx;
	};

	//sigmoid version 
	//parameters: [r0, r1, r2, t0, t1, t2; r0, r1, r2, t0, t1, t2; ...] & [rod_global, t_global]
	class F3 : public CostFunction, public DeformGraphOptMultiDataPlusStatic
	{
	public:
		F3(int graphIdx_, int vtIdx_)
		{
			assert(graphIdx_<graphs.size());
			this->graphIdx = graphIdx_;

			assert(vtIdx_<surfaces[graphIdx]->vtNum);
			this->ngn = &((*(ngns_dense[graphIdx]))[vtIdx_]);
			this->v = surfaces[graphIdx]->vt_data_block(vtIdx_);
			this->vtIdx = vtIdx_;

			this->set_num_residuals(1);
			int ngn_num = this->ngn->neighborIndices.size();
			for (int i = 0; i<ngn_num; i++)
			{
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
			}
			this->mutable_parameter_block_sizes()->push_back(3);
			this->mutable_parameter_block_sizes()->push_back(3);
		}
		~F3() {};

	public:
		virtual bool Evaluate(double const* const* parameters,
			double* residuals,
			double** jacobians) const
		{
			CSurface<float> const& surface_t = surfaces_t[graphIdx];
			int ngn_num = this->ngn->neighborIndices.size();
			DeformGraph const* graph = this->graphs[graphIdx];

			vnl_vector_fixed<double, 3> const& T_global = graph->global_rigid.t;
			vnl_vector_fixed<double, 3> rod_global = graph->global_rigid.rod;
			vnl_matrix_fixed<double, 3, 3> R_global(0.0);
			//d(R)/d(rod)
			vnl_matrix_fixed<double, 9, 3> dR_drod(0.0);
			cv::Mat dR_drod_cv = cv::Mat(9, 3, CV_64F, dR_drod.data_block());
			cv::Mat rod_cv = cv::Mat(1, 3, CV_64F, &rod_global[0]);
			cv::Mat R_cv = cv::Mat(3, 3, CV_64F, R_global.data_block());
			cv::Rodrigues(rod_cv, R_cv, dR_drod_cv);

			vnl_vector_fixed<double, 3> vt(v[0], v[1], v[2]);
			float const* n_ = surfaces[graphIdx]->vt_normal(vtIdx);
			vnl_vector_fixed<double, 3> n(n_[0], n_[1], n_[2]);

			float const* vt_t_ = surface_t.vt_data_block(vtIdx);
			vnl_vector_fixed<double, 3> vt_t(vt_t_[0], vt_t_[1], vt_t_[2]);
			float const* n_t_ = surface_t.vt_normal(vtIdx);
			vnl_vector_fixed<double, 3> n_t(n_t_[0], n_t_[1], n_t_[2]);

			vnl_vector_fixed<double, 3> df_dvtt;
			vnl_vector_fixed<double, 3> df_dnt;
			((TSDF*)sdf_target)->val_der_sigmoid_ck(vt_t.data_block(), n_t.data_block(), residuals[0], df_dvtt, df_dnt);
			
			if (jacobians != NULL)
			{
				vnl_matrix_fixed<double, 3, 3> const&dvtt_dvttn = R_global;
				vnl_matrix_fixed<double, 3, 3> const&dnt_dntn = R_global;

				vnl_vector_fixed<double, 3> df_dvttn = df_dvtt * dvtt_dvttn;
				vnl_vector_fixed<double, 3> df_dntn = df_dnt * dnt_dntn;

				vnl_vector_fixed<double, 3> n_tnu(0.0); //unnormalized normal after nonrigid deformation
				for (int i = 0; i < ngn_num; i++)
				{
					int ndIdx = this->ngn->neighborIndices[i];
					double w_i = this->ngn->weights[i];
					vnl_matrix_fixed<double, 3, 3> const& A_i = graph->nodes[ndIdx].A;
					n_tnu += w_i*vnl_inverse(A_i).transpose()*n;
				}

				vnl_matrix_fixed<double, 3, 3> dntn_dntnu;
				vnl_vector_fixed<double, 3> n_tn;
				Jac_normalization(n_tnu, n_tn, dntn_dntnu);
				vnl_vector_fixed<double, 3> df_dntnu = df_dntn*dntn_dntnu;

				vnl_vector_fixed<double, 3> vt_tn(0.0); //nonrigidly transformed point
				for (int i = 0; i < ngn_num; i++)
				{
					int ndIdx = this->ngn->neighborIndices[i];
					double w_k = this->ngn->weights[i];
					vnl_matrix_fixed<double, 3, 3> const& A_k = graph->nodes[ndIdx].A;
					vnl_vector_fixed<double, 3> const&t_k = graph->nodes[ndIdx].t;
					vnl_vector_fixed<double, 3> const& g_k = graph->nodes[ndIdx].g;

					vnl_vector_fixed<double, 3> tmp;
					tmp[0] = vt[0] - g_k[0];
					tmp[1] = vt[1] - g_k[1];
					tmp[2] = vt[2] - g_k[2];
					vt_tn += (A_k *tmp + g_k + t_k)*w_k;

					vnl_matrix_fixed<double, 3, 9> dntnu_dAi;
					Jac_affine_on_normal(A_k, w_k, n, dntnu_dAi);

					vnl_vector_fixed<double, 9> df_dAi = df_dntnu*dntnu_dAi;

					if (jacobians[6 * i] != NULL)
					{
						//df0/dr0
						jacobians[6 * i][0] = df_dvttn[0] * tmp[0] * w_k + df_dAi(0);
						jacobians[6 * i][1] = df_dvttn[0] * tmp[1] * w_k + df_dAi(1);
						jacobians[6 * i][2] = df_dvttn[0] * tmp[2] * w_k + df_dAi(2);
					}
					if (jacobians[6 * i + 1] != NULL)
					{
						//df0/dr1
						jacobians[6 * i + 1][0] = df_dvttn[1] * tmp[0] * w_k + df_dAi(3);
						jacobians[6 * i + 1][1] = df_dvttn[1] * tmp[1] * w_k + df_dAi(4);
						jacobians[6 * i + 1][2] = df_dvttn[1] * tmp[2] * w_k + df_dAi(5);
					}
					if (jacobians[6 * i + 2] != NULL)
					{
						//df0/dr2
						jacobians[6 * i + 2][0] = df_dvttn[2] * tmp[0] * w_k + df_dAi(6);
						jacobians[6 * i + 2][1] = df_dvttn[2] * tmp[1] * w_k + df_dAi(7);
						jacobians[6 * i + 2][2] = df_dvttn[2] * tmp[2] * w_k + df_dAi(8);
					}

					if (jacobians[6 * i + 3] != NULL)
					{
						//df0/dt0
						jacobians[6 * i + 3][0] = df_dvttn[0] * w_k;
					}
					if (jacobians[6 * i + 4] != NULL)
					{
						//df0/dt1
						jacobians[6 * i + 4][0] = df_dvttn[1] * w_k;
					}
					if (jacobians[6 * i + 5] != NULL)
					{
						//df0/dt2
						jacobians[6 * i + 5][0] = df_dvttn[2] * w_k;
					}
				}

				if (jacobians[6 * ngn_num] != NULL)
				{
					vnl_matrix_fixed<double, 3, 9> dvtt_dR(0.0);
					for (int i = 0; i < 3; i++)
					{
						dvtt_dR(0, i) = vt_tn[i];
						dvtt_dR(1, 3 + i) = vt_tn[i];
						dvtt_dR(2, 6 + i) = vt_tn[i];
					}

					vnl_matrix_fixed<double, 3, 9> dnt_dR(0.0);
					for (int i = 0; i < 3; i++)
					{
						dnt_dR(0, i) = n_tn[i];
						dnt_dR(1, i + 3) = n_tn[i];
						dnt_dR(2, i + 6) = n_tn[i];
					}

					vnl_vector_fixed<double, 9> df_dR = df_dvtt * dvtt_dR + df_dnt*dnt_dR;
					vnl_vector_fixed<double, 3> df_drod = df_dR * dR_drod;
					memcpy(jacobians[6 * ngn_num], df_drod.data_block(), 3 * sizeof(double));
				}

				if (jacobians[6 * ngn_num + 1] != NULL)
				{
					//df0/dt
					jacobians[6 * ngn_num + 1][0] = df_dvtt[0];
					jacobians[6 * ngn_num + 1][1] = df_dvtt[1];
					jacobians[6 * ngn_num + 1][2] = df_dvtt[2];
				}
			}
			return true;
		}

	private:
		NeighborGraphNodesOfPoint *ngn;
		float* v;
		//float* n;
		int graphIdx;
		int vtIdx;
	};

	//sigmoid version *for gradient_check*
	//parameters: [r0, r1, r2, t0, t1, t2; r0, r1, r2, t0, t1, t2; ...] & [rod_global, t_global]
	class F3_ : public CostFunction, public DeformGraphOptMultiDataPlusStatic
	{
	public:
		F3_(int graphIdx_, int vtIdx_)
		{
			assert(graphIdx_<graphs.size());
			this->graphIdx = graphIdx_;

			assert(vtIdx_<surfaces[graphIdx]->vtNum);
			this->ngn = &((*(ngns_dense[graphIdx]))[vtIdx_]);
			this->v = surfaces[graphIdx]->vt_data_block(vtIdx_);
			this->vtIdx = vtIdx_;

			this->set_num_residuals(1);
			int ngn_num = this->ngn->neighborIndices.size();
			for (int i = 0; i<ngn_num; i++)
			{
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(3); //r
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
				this->mutable_parameter_block_sizes()->push_back(1); //t
			}
			this->mutable_parameter_block_sizes()->push_back(3);
			this->mutable_parameter_block_sizes()->push_back(3);
		}
		~F3_() {};

	public:
		virtual bool Evaluate(double const* const* parameters,
			double* residuals,
			double** jacobians) const
		{
			int ngn_num = this->ngn->neighborIndices.size();
			DeformGraph const* graph = this->graphs[graphIdx];

			vnl_vector_fixed<double, 3> T_global(parameters[6*ngn_num+1]);
			vnl_vector_fixed<double, 3> rod_global(parameters[6*ngn_num]);
			vnl_matrix_fixed<double, 3, 3> R_global(0.0);
			//d(R)/d(rod)
			vnl_matrix_fixed<double, 9, 3> dR_drod(0.0);
			cv::Mat dR_drod_cv = cv::Mat(9, 3, CV_64F, dR_drod.data_block());
			cv::Mat rod_cv = cv::Mat(1, 3, CV_64F, &rod_global[0]);
			cv::Mat R_cv = cv::Mat(3, 3, CV_64F, R_global.data_block());
			cv::Rodrigues(rod_cv, R_cv, dR_drod_cv);

			vnl_vector_fixed<double, 3> vt(v[0], v[1], v[2]);
			float const* n_ = surfaces[graphIdx]->vt_normal(vtIdx);
			vnl_vector_fixed<double, 3> n(n_[0], n_[1], n_[2]);

			vnl_vector_fixed<double, 3> vt_t(0.0);
			vnl_vector_fixed<double, 3> n_t(0.0);
			for (int i = 0; i < ngn_num; i++)
			{
				int ndIdx = this->ngn->neighborIndices[i];
				double w_i = this->ngn->weights[i];
				vnl_vector_fixed<double, 3> const& g_i = graph->nodes[ndIdx].g;
				vnl_matrix_fixed<double, 3, 3> A_i;
				A_i.set_row(0, parameters[6 * i]);
				A_i.set_row(1, parameters[6 * i + 1]);
				A_i.set_row(2, parameters[6 * i + 2]);
				vnl_vector_fixed<double, 3> t_i(parameters[6 * i + 3][0], parameters[6 * i + 4][0], parameters[6 * i + 5][0]);

				vt_t += (A_i*(vt - g_i) + g_i + t_i)*w_i;
				n_t += vnl_inverse(A_i).transpose()*n*w_i;
			}
			vt_t = R_global*vt_t + T_global;
			n_t.normalize();
			n_t = R_global*n_t;

			vnl_vector_fixed<double, 3> df_dvtt;
			vnl_vector_fixed<double, 3> df_dnt;
			((TSDF*)sdf_target)->val_der_sigmoid(vt_t.data_block(), n_t.data_block(), residuals[0], df_dvtt, df_dnt);

			if (jacobians != NULL)
			{
				vnl_matrix_fixed<double, 3, 3> const&dvtt_dvttn = R_global;
				vnl_matrix_fixed<double, 3, 3> const&dnt_dntn = R_global;

				vnl_vector_fixed<double, 3> df_dvttn = df_dvtt * dvtt_dvttn;
				vnl_vector_fixed<double, 3> df_dntn = df_dnt * dnt_dntn;

				vnl_vector_fixed<double, 3> n_tnu(0.0); //unnormalized normal after nonrigid deformation
				for (int i = 0; i < ngn_num; i++)
				{
					int ndIdx = this->ngn->neighborIndices[i];
					double w_i = this->ngn->weights[i];
					vnl_matrix_fixed<double, 3, 3> A_i;
					A_i.set_row(0, parameters[6 * i]);
					A_i.set_row(1, parameters[6 * i + 1]);
					A_i.set_row(2, parameters[6 * i + 2]);
					n_tnu += w_i*vnl_inverse(A_i).transpose()*n;
				}

				vnl_matrix_fixed<double, 3, 3> dntn_dntnu;
				vnl_vector_fixed<double, 3> n_tn;
				Jac_normalization(n_tnu, n_tn, dntn_dntnu);
				vnl_vector_fixed<double, 3> df_dntnu = df_dntn*dntn_dntnu;

				vnl_vector_fixed<double, 3> vt_tn(0.0); //nonrigidly transformed point
				for (int i = 0; i < ngn_num; i++)
				{
					int ndIdx = this->ngn->neighborIndices[i];
					double w_k = this->ngn->weights[i];
					vnl_vector_fixed<double, 3> const& g_k = graph->nodes[ndIdx].g;
					vnl_matrix_fixed<double, 3, 3> A_k;
					A_k.set_row(0, parameters[6 * i]);
					A_k.set_row(1, parameters[6 * i + 1]);
					A_k.set_row(2, parameters[6 * i + 2]);
					vnl_vector_fixed<double, 3> t_k(parameters[6 * i + 3][0], parameters[6 * i + 4][0], parameters[6 * i + 5][0]);

					vnl_vector_fixed<double, 3> tmp;
					tmp[0] = vt[0] - g_k[0];
					tmp[1] = vt[1] - g_k[1];
					tmp[2] = vt[2] - g_k[2];
					vt_tn += (A_k *tmp + g_k + t_k)*w_k;

					vnl_matrix_fixed<double, 3, 9> dntnu_dAi;
					Jac_affine_on_normal(A_k, w_k, n, dntnu_dAi);

					vnl_vector_fixed<double, 9> df_dAi = df_dntnu*dntnu_dAi;

					if (jacobians[6 * i] != NULL)
					{
						//df0/dr0
						jacobians[6 * i][0] = df_dvttn[0] * tmp[0] * w_k + df_dAi(0);
						jacobians[6 * i][1] = df_dvttn[0] * tmp[1] * w_k + df_dAi(1);
						jacobians[6 * i][2] = df_dvttn[0] * tmp[2] * w_k + df_dAi(2);
					}
					if (jacobians[6 * i + 1] != NULL)
					{
						//df0/dr1
						jacobians[6 * i + 1][0] = df_dvttn[1] * tmp[0] * w_k + df_dAi(3);
						jacobians[6 * i + 1][1] = df_dvttn[1] * tmp[1] * w_k + df_dAi(4);
						jacobians[6 * i + 1][2] = df_dvttn[1] * tmp[2] * w_k + df_dAi(5);
					}
					if (jacobians[6 * i + 2] != NULL)
					{
						//df0/dr2
						jacobians[6 * i + 2][0] = df_dvttn[2] * tmp[0] * w_k + df_dAi(6);
						jacobians[6 * i + 2][1] = df_dvttn[2] * tmp[1] * w_k + df_dAi(7);
						jacobians[6 * i + 2][2] = df_dvttn[2] * tmp[2] * w_k + df_dAi(8);
					}

					if (jacobians[6 * i + 3] != NULL)
					{
						//df0/dt0
						jacobians[6 * i + 3][0] = df_dvttn[0] * w_k;
					}
					if (jacobians[6 * i + 4] != NULL)
					{
						//df0/dt1
						jacobians[6 * i + 4][0] = df_dvttn[1] * w_k;
					}
					if (jacobians[6 * i + 5] != NULL)
					{
						//df0/dt2
						jacobians[6 * i + 5][0] = df_dvttn[2] * w_k;
					}
				}

				if (jacobians[6 * ngn_num] != NULL)
				{
					vnl_matrix_fixed<double, 3, 9> dvtt_dR(0.0);
					for (int i = 0; i < 3; i++)
					{
						dvtt_dR(0, i) = vt_tn[i];
						dvtt_dR(1, 3 + i) = vt_tn[i];
						dvtt_dR(2, 6 + i) = vt_tn[i];
					}

					vnl_matrix_fixed<double, 3, 9> dnt_dR(0.0);
					for (int i = 0; i < 3; i++)
					{
						dnt_dR(0, i) = n_tn[i];
						dnt_dR(1, i + 3) = n_tn[i];
						dnt_dR(2, i + 6) = n_tn[i];
					}

					vnl_vector_fixed<double, 9> df_dR = df_dvtt * dvtt_dR + df_dnt*dnt_dR;
					vnl_vector_fixed<double, 3> df_drod = df_dR * dR_drod;
					memcpy(jacobians[6 * ngn_num], df_drod.data_block(), 3 * sizeof(double));
				}

				if (jacobians[6 * ngn_num + 1] != NULL)
				{
					//df0/dt
					jacobians[6 * ngn_num + 1][0] = df_dvtt[0];
					jacobians[6 * ngn_num + 1][1] = df_dvtt[1];
					jacobians[6 * ngn_num + 1][2] = df_dvtt[2];
				}
			}
			return true;
		}

	private:
		NeighborGraphNodesOfPoint *ngn;
		float* v;
		//float* n;
		int graphIdx;
		int vtIdx;
	};

	//approximation. diagnolize the J^T J
	//parameters: [r0, r1, r2, t0, t1, t2]
	class F4 : public CostFunction, public DeformGraphOptMultiDataPlusStatic
	{
	public:
		F4(int graphIdx_, int vtIdx_, int lNdIdx_)
		{
			assert(graphIdx_<graphs.size());
			this->graphIdx = graphIdx_;

			assert(vtIdx_<surfaces[graphIdx]->vtNum);
			this->ngn = &((*(ngns_dense[graphIdx]))[vtIdx_]);
			this->v = surfaces[graphIdx]->vt_data_block(vtIdx_);
			this->vtIdx = vtIdx_;

			this->set_num_residuals(1);
			int ngn_num = this->ngn->neighborIndices.size();
			assert(lNdIdx_ < ngn_num);
			this->lNdIdx = lNdIdx_;

			this->mutable_parameter_block_sizes()->push_back(3); //r0
			this->mutable_parameter_block_sizes()->push_back(3); //r1
			this->mutable_parameter_block_sizes()->push_back(3); //r2
			this->mutable_parameter_block_sizes()->push_back(1); //t0
			this->mutable_parameter_block_sizes()->push_back(1); //t1
			this->mutable_parameter_block_sizes()->push_back(1); //t2
		}
		~F4() {};

	public:
		virtual bool Evaluate(double const* const* parameters,
			double* residuals,
			double** jacobians) const
		{
			CSurface<float> const& surface_t = surfaces_t[graphIdx];
			int ngn_num = this->ngn->neighborIndices.size();
			DeformGraph const* graph = this->graphs[graphIdx];

			vnl_vector_fixed<double, 3> const& T_global = graph->global_rigid.t;
			vnl_vector_fixed<double, 3> rod_global = graph->global_rigid.rod;
			vnl_matrix_fixed<double, 3, 3> R_global(0.0);
			//d(R)/d(rod)
			vnl_matrix_fixed<double, 9, 3> dR_drod(0.0);
			cv::Mat dR_drod_cv = cv::Mat(9, 3, CV_64F, dR_drod.data_block());
			cv::Mat rod_cv = cv::Mat(1, 3, CV_64F, &rod_global[0]);
			cv::Mat R_cv = cv::Mat(3, 3, CV_64F, R_global.data_block());
			cv::Rodrigues(rod_cv, R_cv, dR_drod_cv);

			vnl_vector_fixed<double, 3> vt(v[0], v[1], v[2]);
			float const* vt_t_ = surface_t.vt_data_block(vtIdx);
			vnl_vector_fixed<double, 3> vt_t(vt_t_[0], vt_t_[1], vt_t_[2]);
			float const* n_t_ = surface_t.vt_normal(vtIdx);
			vnl_vector_fixed<double, 3> n_t(n_t_[0], n_t_[1], n_t_[2]);

			residuals[0] = sdf_target->val_at(vt_t.data_block(), NULL, 1.0);

			vnl_vector_fixed<double, 3> df_dvtt = sdf_target->der_at(vt_t.data_block(), n_t.data_block(), 75);
			vnl_vector_fixed<double, 3> df_dvttn = df_dvtt * R_global;

			int ndIdx = this->ngn->neighborIndices[lNdIdx];
			double w_k = this->ngn->weights[lNdIdx];
			vnl_matrix_fixed<double, 3, 3> const& A_k = graph->nodes[ndIdx].A;
			vnl_vector_fixed<double, 3> const&t_k = graph->nodes[ndIdx].t;
			vnl_vector_fixed<double, 3> const& g_k = graph->nodes[ndIdx].g;

			vnl_vector_fixed<double, 3> tmp;
			tmp[0] = vt[0] - g_k[0];
			tmp[1] = vt[1] - g_k[1];
			tmp[2] = vt[2] - g_k[2];

			if (jacobians != NULL)
			{
				double w = w_k;
				if (jacobians[0] != NULL)
				{
					//df0/dr0
					jacobians[0][0] = df_dvttn[0] * tmp[0] * w_k;
					jacobians[0][1] = df_dvttn[0] * tmp[1] * w_k;
					jacobians[0][2] = df_dvttn[0] * tmp[2] * w_k;
				}
				if (jacobians[1] != NULL)
				{
					//df0/dr1
					jacobians[1][0] = df_dvttn[1] * tmp[0] * w_k;
					jacobians[1][1] = df_dvttn[1] * tmp[1] * w_k;
					jacobians[1][2] = df_dvttn[1] * tmp[2] * w_k;
				}
				if (jacobians[2] != NULL)
				{
					//df0/dr2
					jacobians[2][0] = df_dvttn[2] * tmp[0] * w_k;
					jacobians[2][1] = df_dvttn[2] * tmp[1] * w_k;
					jacobians[2][2] = df_dvttn[2] * tmp[2] * w_k;
				}

				if (jacobians[3] != NULL)
				{
					//df0/dt0
					jacobians[3][0] = df_dvttn[0] * w_k;
				}
				if (jacobians[4] != NULL)
				{
					//df0/dt1
					jacobians[4][0] = df_dvttn[1] * w_k;
				}
				if (jacobians[5] != NULL)
				{
					//df0/dt2
					jacobians[5][0] = df_dvttn[2] * w_k;
				}
			}
			return true;
		}

	private:
		NeighborGraphNodesOfPoint *ngn;
		float* v;
		//float* n;
		int graphIdx;
		int vtIdx;
		int lNdIdx;
	};

	class DensePtAlignFunctor : public DeformGraphOptMultiDataPlusStatic
	{
	public:
		DensePtAlignFunctor(int graphIdx_, int vtIdx_)
		{
			assert(graphIdx_<graphs.size());
			this->graphIdx = graphIdx_;

			assert(vtIdx_<surfaces[graphIdx]->vtNum);
			this->ngn = &((*(ngns_dense[graphIdx]))[vtIdx_]);
			this->v = surfaces[graphIdx]->vt_data_block(vtIdx_);
			this->vtIdx = vtIdx_;
		}
		~DensePtAlignFunctor() {};

	public:
		template<typename T>
		bool operator()(T const* const* parameters,
						T* residuals) const
		{
			int ngn_num = this->ngn->neighborIndices.size();
			DeformGraph const* graph = this->graphs[graphIdx];

			vnl_vector_fixed<double, 3> T_global;
			T_global[0] = parameters[6 * ngn_num + 1][0];
			T_global[1] = parameters[6 * ngn_num + 1][1];
			T_global[2] = parameters[6 * ngn_num + 1][2];

			vnl_vector_fixed<double, 3> rod_global;
			rod_global[0] = parameters[6 * ngn_num][0];
			rod_global[1] = parameters[6 * ngn_num][1];
			rod_global[2] = parameters[6 * ngn_num][2];

			vnl_matrix_fixed<double, 3, 3> R_global;
			rodrigues_to_matrix(rod_global, R_global);

			vnl_vector_fixed<double, 3> vt(v[0], v[1], v[2]);
			float const* n_ = surfaces[graphIdx]->vt_normal(vtIdx);
			vnl_vector_fixed<double, 3> n(n_[0], n_[1], n_[2]);

			vnl_vector_fixed<double, 3> vt_t(0.0);
			vnl_vector_fixed<double, 3> n_t(0.0);
			for (int i = 0; i < ngn_num; i++)
			{
				int ndIdx = this->ngn->neighborIndices[i];
				double w_i = this->ngn->weights[i];
				vnl_vector_fixed<double, 3> const& g_i = graph->nodes[ndIdx].g;
				vnl_matrix_fixed<double, 3, 3> A_i;
				A_i(0, 0) = parameters[6 * i][0];
				A_i(0, 1) = parameters[6 * i][1];
				A_i(0, 2) = parameters[6 * i][2];
				A_i(1, 0) = parameters[6 * i + 1][0];
				A_i(1, 1) = parameters[6 * i + 1][1];
				A_i(1, 2) = parameters[6 * i + 1][2];
				A_i(2, 0) = parameters[6 * i + 2][0];
				A_i(2, 1) = parameters[6 * i + 2][1];
				A_i(2, 2) = parameters[6 * i + 2][2];
				vnl_vector_fixed<double, 3> t_i;
				t_i[0] = parameters[6 * i + 3][0];
				t_i[1] = parameters[6 * i + 4][0];
				t_i[2] = parameters[6 * i + 5][0];

				vt_t += (A_i*(vt - g_i) + g_i + t_i)*w_i;
				n_t += vnl_inverse(A_i).transpose()*n*w_i;
			}
			vt_t = R_global*vt_t + T_global;
			n_t.normalize();
			n_t = R_global*n_t;

			vnl_vector_fixed<double, 3> df_dvtt;
			vnl_vector_fixed<double, 3> df_dnt;
			double res = 0;
			((TSDF*)sdf_target)->val_der_sigmoid_ck(vt_t.data_block(), n_t.data_block(), res, df_dvtt, df_dnt);
			residuals[0] = res;
			
			return true;
		}

	private:
		NeighborGraphNodesOfPoint *ngn;
		float* v;
		int graphIdx;
		int vtIdx;
	};
};


#endif

}
#endif